[
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "orm",
        "importPath": "aiida",
        "description": "aiida",
        "isExtraImport": true,
        "detail": "aiida",
        "documentation": {}
    },
    {
        "label": "orm",
        "importPath": "aiida",
        "description": "aiida",
        "isExtraImport": true,
        "detail": "aiida",
        "documentation": {}
    },
    {
        "label": "orm",
        "importPath": "aiida",
        "description": "aiida",
        "isExtraImport": true,
        "detail": "aiida",
        "documentation": {}
    },
    {
        "label": "orm",
        "importPath": "aiida",
        "description": "aiida",
        "isExtraImport": true,
        "detail": "aiida",
        "documentation": {}
    },
    {
        "label": "orm",
        "importPath": "aiida",
        "description": "aiida",
        "isExtraImport": true,
        "detail": "aiida",
        "documentation": {}
    },
    {
        "label": "orm",
        "importPath": "aiida",
        "description": "aiida",
        "isExtraImport": true,
        "detail": "aiida",
        "documentation": {}
    },
    {
        "label": "orm",
        "importPath": "aiida",
        "description": "aiida",
        "isExtraImport": true,
        "detail": "aiida",
        "documentation": {}
    },
    {
        "label": "orm",
        "importPath": "aiida",
        "description": "aiida",
        "isExtraImport": true,
        "detail": "aiida",
        "documentation": {}
    },
    {
        "label": "orm",
        "importPath": "aiida",
        "description": "aiida",
        "isExtraImport": true,
        "detail": "aiida",
        "documentation": {}
    },
    {
        "label": "orm",
        "importPath": "aiida",
        "description": "aiida",
        "isExtraImport": true,
        "detail": "aiida",
        "documentation": {}
    },
    {
        "label": "orm",
        "importPath": "aiida",
        "description": "aiida",
        "isExtraImport": true,
        "detail": "aiida",
        "documentation": {}
    },
    {
        "label": "orm",
        "importPath": "aiida",
        "description": "aiida",
        "isExtraImport": true,
        "detail": "aiida",
        "documentation": {}
    },
    {
        "label": "orm",
        "importPath": "aiida",
        "description": "aiida",
        "isExtraImport": true,
        "detail": "aiida",
        "documentation": {}
    },
    {
        "label": "orm",
        "importPath": "aiida",
        "description": "aiida",
        "isExtraImport": true,
        "detail": "aiida",
        "documentation": {}
    },
    {
        "label": "orm",
        "importPath": "aiida",
        "description": "aiida",
        "isExtraImport": true,
        "detail": "aiida",
        "documentation": {}
    },
    {
        "label": "orm",
        "importPath": "aiida",
        "description": "aiida",
        "isExtraImport": true,
        "detail": "aiida",
        "documentation": {}
    },
    {
        "label": "orm",
        "importPath": "aiida",
        "description": "aiida",
        "isExtraImport": true,
        "detail": "aiida",
        "documentation": {}
    },
    {
        "label": "orm",
        "importPath": "aiida",
        "description": "aiida",
        "isExtraImport": true,
        "detail": "aiida",
        "documentation": {}
    },
    {
        "label": "orm",
        "importPath": "aiida",
        "description": "aiida",
        "isExtraImport": true,
        "detail": "aiida",
        "documentation": {}
    },
    {
        "label": "orm",
        "importPath": "aiida",
        "description": "aiida",
        "isExtraImport": true,
        "detail": "aiida",
        "documentation": {}
    },
    {
        "label": "orm",
        "importPath": "aiida",
        "description": "aiida",
        "isExtraImport": true,
        "detail": "aiida",
        "documentation": {}
    },
    {
        "label": "orm",
        "importPath": "aiida",
        "description": "aiida",
        "isExtraImport": true,
        "detail": "aiida",
        "documentation": {}
    },
    {
        "label": "orm",
        "importPath": "aiida",
        "description": "aiida",
        "isExtraImport": true,
        "detail": "aiida",
        "documentation": {}
    },
    {
        "label": "orm",
        "importPath": "aiida",
        "description": "aiida",
        "isExtraImport": true,
        "detail": "aiida",
        "documentation": {}
    },
    {
        "label": "orm",
        "importPath": "aiida",
        "description": "aiida",
        "isExtraImport": true,
        "detail": "aiida",
        "documentation": {}
    },
    {
        "label": "orm",
        "importPath": "aiida",
        "description": "aiida",
        "isExtraImport": true,
        "detail": "aiida",
        "documentation": {}
    },
    {
        "label": "orm",
        "importPath": "aiida",
        "description": "aiida",
        "isExtraImport": true,
        "detail": "aiida",
        "documentation": {}
    },
    {
        "label": "orm",
        "importPath": "aiida",
        "description": "aiida",
        "isExtraImport": true,
        "detail": "aiida",
        "documentation": {}
    },
    {
        "label": "orm",
        "importPath": "aiida",
        "description": "aiida",
        "isExtraImport": true,
        "detail": "aiida",
        "documentation": {}
    },
    {
        "label": "orm",
        "importPath": "aiida",
        "description": "aiida",
        "isExtraImport": true,
        "detail": "aiida",
        "documentation": {}
    },
    {
        "label": "orm",
        "importPath": "aiida",
        "description": "aiida",
        "isExtraImport": true,
        "detail": "aiida",
        "documentation": {}
    },
    {
        "label": "orm",
        "importPath": "aiida",
        "description": "aiida",
        "isExtraImport": true,
        "detail": "aiida",
        "documentation": {}
    },
    {
        "label": "orm",
        "importPath": "aiida",
        "description": "aiida",
        "isExtraImport": true,
        "detail": "aiida",
        "documentation": {}
    },
    {
        "label": "orm",
        "importPath": "aiida",
        "description": "aiida",
        "isExtraImport": true,
        "detail": "aiida",
        "documentation": {}
    },
    {
        "label": "orm",
        "importPath": "aiida",
        "description": "aiida",
        "isExtraImport": true,
        "detail": "aiida",
        "documentation": {}
    },
    {
        "label": "orm",
        "importPath": "aiida",
        "description": "aiida",
        "isExtraImport": true,
        "detail": "aiida",
        "documentation": {}
    },
    {
        "label": "orm",
        "importPath": "aiida",
        "description": "aiida",
        "isExtraImport": true,
        "detail": "aiida",
        "documentation": {}
    },
    {
        "label": "calcfunction",
        "importPath": "aiida.engine",
        "description": "aiida.engine",
        "isExtraImport": true,
        "detail": "aiida.engine",
        "documentation": {}
    },
    {
        "label": "ExitCode",
        "importPath": "aiida.engine",
        "description": "aiida.engine",
        "isExtraImport": true,
        "detail": "aiida.engine",
        "documentation": {}
    },
    {
        "label": "WorkChain",
        "importPath": "aiida.engine",
        "description": "aiida.engine",
        "isExtraImport": true,
        "detail": "aiida.engine",
        "documentation": {}
    },
    {
        "label": "ToContext",
        "importPath": "aiida.engine",
        "description": "aiida.engine",
        "isExtraImport": true,
        "detail": "aiida.engine",
        "documentation": {}
    },
    {
        "label": "if_",
        "importPath": "aiida.engine",
        "description": "aiida.engine",
        "isExtraImport": true,
        "detail": "aiida.engine",
        "documentation": {}
    },
    {
        "label": "WorkChain",
        "importPath": "aiida.engine",
        "description": "aiida.engine",
        "isExtraImport": true,
        "detail": "aiida.engine",
        "documentation": {}
    },
    {
        "label": "ToContext",
        "importPath": "aiida.engine",
        "description": "aiida.engine",
        "isExtraImport": true,
        "detail": "aiida.engine",
        "documentation": {}
    },
    {
        "label": "if_",
        "importPath": "aiida.engine",
        "description": "aiida.engine",
        "isExtraImport": true,
        "detail": "aiida.engine",
        "documentation": {}
    },
    {
        "label": "while_",
        "importPath": "aiida.engine",
        "description": "aiida.engine",
        "isExtraImport": true,
        "detail": "aiida.engine",
        "documentation": {}
    },
    {
        "label": "while_",
        "importPath": "aiida.engine",
        "description": "aiida.engine",
        "isExtraImport": true,
        "detail": "aiida.engine",
        "documentation": {}
    },
    {
        "label": "process_handler",
        "importPath": "aiida.engine",
        "description": "aiida.engine",
        "isExtraImport": true,
        "detail": "aiida.engine",
        "documentation": {}
    },
    {
        "label": "ProcessHandlerReport",
        "importPath": "aiida.engine",
        "description": "aiida.engine",
        "isExtraImport": true,
        "detail": "aiida.engine",
        "documentation": {}
    },
    {
        "label": "WorkChain",
        "importPath": "aiida.engine",
        "description": "aiida.engine",
        "isExtraImport": true,
        "detail": "aiida.engine",
        "documentation": {}
    },
    {
        "label": "ToContext",
        "importPath": "aiida.engine",
        "description": "aiida.engine",
        "isExtraImport": true,
        "detail": "aiida.engine",
        "documentation": {}
    },
    {
        "label": "WorkChain",
        "importPath": "aiida.engine",
        "description": "aiida.engine",
        "isExtraImport": true,
        "detail": "aiida.engine",
        "documentation": {}
    },
    {
        "label": "ToContext",
        "importPath": "aiida.engine",
        "description": "aiida.engine",
        "isExtraImport": true,
        "detail": "aiida.engine",
        "documentation": {}
    },
    {
        "label": "if_",
        "importPath": "aiida.engine",
        "description": "aiida.engine",
        "isExtraImport": true,
        "detail": "aiida.engine",
        "documentation": {}
    },
    {
        "label": "ToContext",
        "importPath": "aiida.engine",
        "description": "aiida.engine",
        "isExtraImport": true,
        "detail": "aiida.engine",
        "documentation": {}
    },
    {
        "label": "if_",
        "importPath": "aiida.engine",
        "description": "aiida.engine",
        "isExtraImport": true,
        "detail": "aiida.engine",
        "documentation": {}
    },
    {
        "label": "while_",
        "importPath": "aiida.engine",
        "description": "aiida.engine",
        "isExtraImport": true,
        "detail": "aiida.engine",
        "documentation": {}
    },
    {
        "label": "BaseRestartWorkChain",
        "importPath": "aiida.engine",
        "description": "aiida.engine",
        "isExtraImport": true,
        "detail": "aiida.engine",
        "documentation": {}
    },
    {
        "label": "process_handler",
        "importPath": "aiida.engine",
        "description": "aiida.engine",
        "isExtraImport": true,
        "detail": "aiida.engine",
        "documentation": {}
    },
    {
        "label": "ProcessHandlerReport",
        "importPath": "aiida.engine",
        "description": "aiida.engine",
        "isExtraImport": true,
        "detail": "aiida.engine",
        "documentation": {}
    },
    {
        "label": "ExitCode",
        "importPath": "aiida.engine",
        "description": "aiida.engine",
        "isExtraImport": true,
        "detail": "aiida.engine",
        "documentation": {}
    },
    {
        "label": "WorkChain",
        "importPath": "aiida.engine",
        "description": "aiida.engine",
        "isExtraImport": true,
        "detail": "aiida.engine",
        "documentation": {}
    },
    {
        "label": "ToContext",
        "importPath": "aiida.engine",
        "description": "aiida.engine",
        "isExtraImport": true,
        "detail": "aiida.engine",
        "documentation": {}
    },
    {
        "label": "if_",
        "importPath": "aiida.engine",
        "description": "aiida.engine",
        "isExtraImport": true,
        "detail": "aiida.engine",
        "documentation": {}
    },
    {
        "label": "while_",
        "importPath": "aiida.engine",
        "description": "aiida.engine",
        "isExtraImport": true,
        "detail": "aiida.engine",
        "documentation": {}
    },
    {
        "label": "append_",
        "importPath": "aiida.engine",
        "description": "aiida.engine",
        "isExtraImport": true,
        "detail": "aiida.engine",
        "documentation": {}
    },
    {
        "label": "WorkChain",
        "importPath": "aiida.engine",
        "description": "aiida.engine",
        "isExtraImport": true,
        "detail": "aiida.engine",
        "documentation": {}
    },
    {
        "label": "ToContext",
        "importPath": "aiida.engine",
        "description": "aiida.engine",
        "isExtraImport": true,
        "detail": "aiida.engine",
        "documentation": {}
    },
    {
        "label": "if_",
        "importPath": "aiida.engine",
        "description": "aiida.engine",
        "isExtraImport": true,
        "detail": "aiida.engine",
        "documentation": {}
    },
    {
        "label": "while_",
        "importPath": "aiida.engine",
        "description": "aiida.engine",
        "isExtraImport": true,
        "detail": "aiida.engine",
        "documentation": {}
    },
    {
        "label": "BaseRestartWorkChain",
        "importPath": "aiida.engine",
        "description": "aiida.engine",
        "isExtraImport": true,
        "detail": "aiida.engine",
        "documentation": {}
    },
    {
        "label": "process_handler",
        "importPath": "aiida.engine",
        "description": "aiida.engine",
        "isExtraImport": true,
        "detail": "aiida.engine",
        "documentation": {}
    },
    {
        "label": "ProcessHandlerReport",
        "importPath": "aiida.engine",
        "description": "aiida.engine",
        "isExtraImport": true,
        "detail": "aiida.engine",
        "documentation": {}
    },
    {
        "label": "submit",
        "importPath": "aiida.engine",
        "description": "aiida.engine",
        "isExtraImport": true,
        "detail": "aiida.engine",
        "documentation": {}
    },
    {
        "label": "run_get_pk",
        "importPath": "aiida.engine",
        "description": "aiida.engine",
        "isExtraImport": true,
        "detail": "aiida.engine",
        "documentation": {}
    },
    {
        "label": "submit",
        "importPath": "aiida.engine",
        "description": "aiida.engine",
        "isExtraImport": true,
        "detail": "aiida.engine",
        "documentation": {}
    },
    {
        "label": "run_get_node",
        "importPath": "aiida.engine",
        "description": "aiida.engine",
        "isExtraImport": true,
        "detail": "aiida.engine",
        "documentation": {}
    },
    {
        "label": "submit",
        "importPath": "aiida.engine",
        "description": "aiida.engine",
        "isExtraImport": true,
        "detail": "aiida.engine",
        "documentation": {}
    },
    {
        "label": "run_get_node",
        "importPath": "aiida.engine",
        "description": "aiida.engine",
        "isExtraImport": true,
        "detail": "aiida.engine",
        "documentation": {}
    },
    {
        "label": "submit",
        "importPath": "aiida.engine",
        "description": "aiida.engine",
        "isExtraImport": true,
        "detail": "aiida.engine",
        "documentation": {}
    },
    {
        "label": "aiida.orm",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "aiida.orm",
        "description": "aiida.orm",
        "detail": "aiida.orm",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "aiida.orm",
        "description": "aiida.orm",
        "isExtraImport": true,
        "detail": "aiida.orm",
        "documentation": {}
    },
    {
        "label": "StructureData",
        "importPath": "aiida.orm",
        "description": "aiida.orm",
        "isExtraImport": true,
        "detail": "aiida.orm",
        "documentation": {}
    },
    {
        "label": "Float",
        "importPath": "aiida.orm",
        "description": "aiida.orm",
        "isExtraImport": true,
        "detail": "aiida.orm",
        "documentation": {}
    },
    {
        "label": "Bool",
        "importPath": "aiida.orm",
        "description": "aiida.orm",
        "isExtraImport": true,
        "detail": "aiida.orm",
        "documentation": {}
    },
    {
        "label": "CalcJobNode",
        "importPath": "aiida.orm",
        "description": "aiida.orm",
        "isExtraImport": true,
        "detail": "aiida.orm",
        "documentation": {}
    },
    {
        "label": "Int",
        "importPath": "aiida.orm",
        "description": "aiida.orm",
        "isExtraImport": true,
        "detail": "aiida.orm",
        "documentation": {}
    },
    {
        "label": "KpointsData",
        "importPath": "aiida.orm",
        "description": "aiida.orm",
        "isExtraImport": true,
        "detail": "aiida.orm",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "aiida.orm",
        "description": "aiida.orm",
        "isExtraImport": true,
        "detail": "aiida.orm",
        "documentation": {}
    },
    {
        "label": "StructureData",
        "importPath": "aiida.orm",
        "description": "aiida.orm",
        "isExtraImport": true,
        "detail": "aiida.orm",
        "documentation": {}
    },
    {
        "label": "Float",
        "importPath": "aiida.orm",
        "description": "aiida.orm",
        "isExtraImport": true,
        "detail": "aiida.orm",
        "documentation": {}
    },
    {
        "label": "Bool",
        "importPath": "aiida.orm",
        "description": "aiida.orm",
        "isExtraImport": true,
        "detail": "aiida.orm",
        "documentation": {}
    },
    {
        "label": "CalcJobNode",
        "importPath": "aiida.orm",
        "description": "aiida.orm",
        "isExtraImport": true,
        "detail": "aiida.orm",
        "documentation": {}
    },
    {
        "label": "Int",
        "importPath": "aiida.orm",
        "description": "aiida.orm",
        "isExtraImport": true,
        "detail": "aiida.orm",
        "documentation": {}
    },
    {
        "label": "KpointsData",
        "importPath": "aiida.orm",
        "description": "aiida.orm",
        "isExtraImport": true,
        "detail": "aiida.orm",
        "documentation": {}
    },
    {
        "label": "load_node",
        "importPath": "aiida.orm",
        "description": "aiida.orm",
        "isExtraImport": true,
        "detail": "aiida.orm",
        "documentation": {}
    },
    {
        "label": "load_node",
        "importPath": "aiida.orm",
        "description": "aiida.orm",
        "isExtraImport": true,
        "detail": "aiida.orm",
        "documentation": {}
    },
    {
        "label": "PerturboParser",
        "importPath": "aiida_mobility.parsers.data_parser.perturbo_parser",
        "description": "aiida_mobility.parsers.data_parser.perturbo_parser",
        "isExtraImport": true,
        "detail": "aiida_mobility.parsers.data_parser.perturbo_parser",
        "documentation": {}
    },
    {
        "label": "get_calc_from_folder",
        "importPath": "aiida_mobility.utils",
        "description": "aiida_mobility.utils",
        "isExtraImport": true,
        "detail": "aiida_mobility.utils",
        "documentation": {}
    },
    {
        "label": "get_calc_from_folder",
        "importPath": "aiida_mobility.utils",
        "description": "aiida_mobility.utils",
        "isExtraImport": true,
        "detail": "aiida_mobility.utils",
        "documentation": {}
    },
    {
        "label": "read_structure",
        "importPath": "aiida_mobility.utils",
        "description": "aiida_mobility.utils",
        "isExtraImport": true,
        "detail": "aiida_mobility.utils",
        "documentation": {}
    },
    {
        "label": "get_metadata_options",
        "importPath": "aiida_mobility.utils",
        "description": "aiida_mobility.utils",
        "isExtraImport": true,
        "detail": "aiida_mobility.utils",
        "documentation": {}
    },
    {
        "label": "get_protocol",
        "importPath": "aiida_mobility.utils",
        "description": "aiida_mobility.utils",
        "isExtraImport": true,
        "detail": "aiida_mobility.utils",
        "documentation": {}
    },
    {
        "label": "get_pw_common_inputs",
        "importPath": "aiida_mobility.utils",
        "description": "aiida_mobility.utils",
        "isExtraImport": true,
        "detail": "aiida_mobility.utils",
        "documentation": {}
    },
    {
        "label": "get_protocol",
        "importPath": "aiida_mobility.utils",
        "description": "aiida_mobility.utils",
        "isExtraImport": true,
        "detail": "aiida_mobility.utils",
        "documentation": {}
    },
    {
        "label": "get_pw_common_inputs",
        "importPath": "aiida_mobility.utils",
        "description": "aiida_mobility.utils",
        "isExtraImport": true,
        "detail": "aiida_mobility.utils",
        "documentation": {}
    },
    {
        "label": "get_protocol",
        "importPath": "aiida_mobility.utils",
        "description": "aiida_mobility.utils",
        "isExtraImport": true,
        "detail": "aiida_mobility.utils",
        "documentation": {}
    },
    {
        "label": "constr2dpath",
        "importPath": "aiida_mobility.utils",
        "description": "aiida_mobility.utils",
        "isExtraImport": true,
        "detail": "aiida_mobility.utils",
        "documentation": {}
    },
    {
        "label": "create_kpoints",
        "importPath": "aiida_mobility.utils",
        "description": "aiida_mobility.utils",
        "isExtraImport": true,
        "detail": "aiida_mobility.utils",
        "documentation": {}
    },
    {
        "label": "get_calc_from_folder",
        "importPath": "aiida_mobility.utils",
        "description": "aiida_mobility.utils",
        "isExtraImport": true,
        "detail": "aiida_mobility.utils",
        "documentation": {}
    },
    {
        "label": "constr2dpath",
        "importPath": "aiida_mobility.utils",
        "description": "aiida_mobility.utils",
        "isExtraImport": true,
        "detail": "aiida_mobility.utils",
        "documentation": {}
    },
    {
        "label": "create_kpoints",
        "importPath": "aiida_mobility.utils",
        "description": "aiida_mobility.utils",
        "isExtraImport": true,
        "detail": "aiida_mobility.utils",
        "documentation": {}
    },
    {
        "label": "input_pw_parameters_helper",
        "importPath": "aiida_mobility.utils",
        "description": "aiida_mobility.utils",
        "isExtraImport": true,
        "detail": "aiida_mobility.utils",
        "documentation": {}
    },
    {
        "label": "create_kpoints",
        "importPath": "aiida_mobility.utils",
        "description": "aiida_mobility.utils",
        "isExtraImport": true,
        "detail": "aiida_mobility.utils",
        "documentation": {}
    },
    {
        "label": "create_kpoints",
        "importPath": "aiida_mobility.utils",
        "description": "aiida_mobility.utils",
        "isExtraImport": true,
        "detail": "aiida_mobility.utils",
        "documentation": {}
    },
    {
        "label": "input_pw_parameters_helper",
        "importPath": "aiida_mobility.utils",
        "description": "aiida_mobility.utils",
        "isExtraImport": true,
        "detail": "aiida_mobility.utils",
        "documentation": {}
    },
    {
        "label": "add_to_group",
        "importPath": "aiida_mobility.utils",
        "description": "aiida_mobility.utils",
        "isExtraImport": true,
        "detail": "aiida_mobility.utils",
        "documentation": {}
    },
    {
        "label": "create_kpoints",
        "importPath": "aiida_mobility.utils",
        "description": "aiida_mobility.utils",
        "isExtraImport": true,
        "detail": "aiida_mobility.utils",
        "documentation": {}
    },
    {
        "label": "print_help",
        "importPath": "aiida_mobility.utils",
        "description": "aiida_mobility.utils",
        "isExtraImport": true,
        "detail": "aiida_mobility.utils",
        "documentation": {}
    },
    {
        "label": "read_structure",
        "importPath": "aiida_mobility.utils",
        "description": "aiida_mobility.utils",
        "isExtraImport": true,
        "detail": "aiida_mobility.utils",
        "documentation": {}
    },
    {
        "label": "write_pk_to_file",
        "importPath": "aiida_mobility.utils",
        "description": "aiida_mobility.utils",
        "isExtraImport": true,
        "detail": "aiida_mobility.utils",
        "documentation": {}
    },
    {
        "label": "add_to_group",
        "importPath": "aiida_mobility.utils",
        "description": "aiida_mobility.utils",
        "isExtraImport": true,
        "detail": "aiida_mobility.utils",
        "documentation": {}
    },
    {
        "label": "print_help",
        "importPath": "aiida_mobility.utils",
        "description": "aiida_mobility.utils",
        "isExtraImport": true,
        "detail": "aiida_mobility.utils",
        "documentation": {}
    },
    {
        "label": "read_structure",
        "importPath": "aiida_mobility.utils",
        "description": "aiida_mobility.utils",
        "isExtraImport": true,
        "detail": "aiida_mobility.utils",
        "documentation": {}
    },
    {
        "label": "write_pk_to_file",
        "importPath": "aiida_mobility.utils",
        "description": "aiida_mobility.utils",
        "isExtraImport": true,
        "detail": "aiida_mobility.utils",
        "documentation": {}
    },
    {
        "label": "get_protocol",
        "importPath": "aiida_mobility.utils",
        "description": "aiida_mobility.utils",
        "isExtraImport": true,
        "detail": "aiida_mobility.utils",
        "documentation": {}
    },
    {
        "label": "get_pw_common_inputs",
        "importPath": "aiida_mobility.utils",
        "description": "aiida_mobility.utils",
        "isExtraImport": true,
        "detail": "aiida_mobility.utils",
        "documentation": {}
    },
    {
        "label": "add_to_group",
        "importPath": "aiida_mobility.utils",
        "description": "aiida_mobility.utils",
        "isExtraImport": true,
        "detail": "aiida_mobility.utils",
        "documentation": {}
    },
    {
        "label": "get_metadata_options",
        "importPath": "aiida_mobility.utils",
        "description": "aiida_mobility.utils",
        "isExtraImport": true,
        "detail": "aiida_mobility.utils",
        "documentation": {}
    },
    {
        "label": "get_protocol",
        "importPath": "aiida_mobility.utils",
        "description": "aiida_mobility.utils",
        "isExtraImport": true,
        "detail": "aiida_mobility.utils",
        "documentation": {}
    },
    {
        "label": "get_pw_common_inputs",
        "importPath": "aiida_mobility.utils",
        "description": "aiida_mobility.utils",
        "isExtraImport": true,
        "detail": "aiida_mobility.utils",
        "documentation": {}
    },
    {
        "label": "print_help",
        "importPath": "aiida_mobility.utils",
        "description": "aiida_mobility.utils",
        "isExtraImport": true,
        "detail": "aiida_mobility.utils",
        "documentation": {}
    },
    {
        "label": "read_structure",
        "importPath": "aiida_mobility.utils",
        "description": "aiida_mobility.utils",
        "isExtraImport": true,
        "detail": "aiida_mobility.utils",
        "documentation": {}
    },
    {
        "label": "write_pk_to_file",
        "importPath": "aiida_mobility.utils",
        "description": "aiida_mobility.utils",
        "isExtraImport": true,
        "detail": "aiida_mobility.utils",
        "documentation": {}
    },
    {
        "label": "add_to_group",
        "importPath": "aiida_mobility.utils",
        "description": "aiida_mobility.utils",
        "isExtraImport": true,
        "detail": "aiida_mobility.utils",
        "documentation": {}
    },
    {
        "label": "create_kpoints",
        "importPath": "aiida_mobility.utils",
        "description": "aiida_mobility.utils",
        "isExtraImport": true,
        "detail": "aiida_mobility.utils",
        "documentation": {}
    },
    {
        "label": "print_help",
        "importPath": "aiida_mobility.utils",
        "description": "aiida_mobility.utils",
        "isExtraImport": true,
        "detail": "aiida_mobility.utils",
        "documentation": {}
    },
    {
        "label": "read_structure",
        "importPath": "aiida_mobility.utils",
        "description": "aiida_mobility.utils",
        "isExtraImport": true,
        "detail": "aiida_mobility.utils",
        "documentation": {}
    },
    {
        "label": "write_pk_to_file",
        "importPath": "aiida_mobility.utils",
        "description": "aiida_mobility.utils",
        "isExtraImport": true,
        "detail": "aiida_mobility.utils",
        "documentation": {}
    },
    {
        "label": "add_to_group",
        "importPath": "aiida_mobility.utils",
        "description": "aiida_mobility.utils",
        "isExtraImport": true,
        "detail": "aiida_mobility.utils",
        "documentation": {}
    },
    {
        "label": "write_pk_to_file",
        "importPath": "aiida_mobility.utils",
        "description": "aiida_mobility.utils",
        "isExtraImport": true,
        "detail": "aiida_mobility.utils",
        "documentation": {}
    },
    {
        "label": "print_help",
        "importPath": "aiida_mobility.utils",
        "description": "aiida_mobility.utils",
        "isExtraImport": true,
        "detail": "aiida_mobility.utils",
        "documentation": {}
    },
    {
        "label": "read_structure",
        "importPath": "aiida_mobility.utils",
        "description": "aiida_mobility.utils",
        "isExtraImport": true,
        "detail": "aiida_mobility.utils",
        "documentation": {}
    },
    {
        "label": "add_to_group",
        "importPath": "aiida_mobility.utils",
        "description": "aiida_mobility.utils",
        "isExtraImport": true,
        "detail": "aiida_mobility.utils",
        "documentation": {}
    },
    {
        "label": "get_protocol",
        "importPath": "aiida_mobility.utils",
        "description": "aiida_mobility.utils",
        "isExtraImport": true,
        "detail": "aiida_mobility.utils",
        "documentation": {}
    },
    {
        "label": "get_pw_common_inputs",
        "importPath": "aiida_mobility.utils",
        "description": "aiida_mobility.utils",
        "isExtraImport": true,
        "detail": "aiida_mobility.utils",
        "documentation": {}
    },
    {
        "label": "write_pk_to_file",
        "importPath": "aiida_mobility.utils",
        "description": "aiida_mobility.utils",
        "isExtraImport": true,
        "detail": "aiida_mobility.utils",
        "documentation": {}
    },
    {
        "label": "print_help",
        "importPath": "aiida_mobility.utils",
        "description": "aiida_mobility.utils",
        "isExtraImport": true,
        "detail": "aiida_mobility.utils",
        "documentation": {}
    },
    {
        "label": "read_structure",
        "importPath": "aiida_mobility.utils",
        "description": "aiida_mobility.utils",
        "isExtraImport": true,
        "detail": "aiida_mobility.utils",
        "documentation": {}
    },
    {
        "label": "add_to_group",
        "importPath": "aiida_mobility.utils",
        "description": "aiida_mobility.utils",
        "isExtraImport": true,
        "detail": "aiida_mobility.utils",
        "documentation": {}
    },
    {
        "label": "print_help",
        "importPath": "aiida_mobility.utils",
        "description": "aiida_mobility.utils",
        "isExtraImport": true,
        "detail": "aiida_mobility.utils",
        "documentation": {}
    },
    {
        "label": "write_pk_to_file",
        "importPath": "aiida_mobility.utils",
        "description": "aiida_mobility.utils",
        "isExtraImport": true,
        "detail": "aiida_mobility.utils",
        "documentation": {}
    },
    {
        "label": "StoreDictKeyPair",
        "importPath": "aiida_mobility.utils",
        "description": "aiida_mobility.utils",
        "isExtraImport": true,
        "detail": "aiida_mobility.utils",
        "documentation": {}
    },
    {
        "label": "add_to_group",
        "importPath": "aiida_mobility.utils",
        "description": "aiida_mobility.utils",
        "isExtraImport": true,
        "detail": "aiida_mobility.utils",
        "documentation": {}
    },
    {
        "label": "print_help",
        "importPath": "aiida_mobility.utils",
        "description": "aiida_mobility.utils",
        "isExtraImport": true,
        "detail": "aiida_mobility.utils",
        "documentation": {}
    },
    {
        "label": "write_pk_to_file",
        "importPath": "aiida_mobility.utils",
        "description": "aiida_mobility.utils",
        "isExtraImport": true,
        "detail": "aiida_mobility.utils",
        "documentation": {}
    },
    {
        "label": "read_structure",
        "importPath": "aiida_mobility.utils",
        "description": "aiida_mobility.utils",
        "isExtraImport": true,
        "detail": "aiida_mobility.utils",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "datastructures",
        "importPath": "aiida.common",
        "description": "aiida.common",
        "isExtraImport": true,
        "detail": "aiida.common",
        "documentation": {}
    },
    {
        "label": "exceptions",
        "importPath": "aiida.common",
        "description": "aiida.common",
        "isExtraImport": true,
        "detail": "aiida.common",
        "documentation": {}
    },
    {
        "label": "datastructures",
        "importPath": "aiida.common",
        "description": "aiida.common",
        "isExtraImport": true,
        "detail": "aiida.common",
        "documentation": {}
    },
    {
        "label": "exceptions",
        "importPath": "aiida.common",
        "description": "aiida.common",
        "isExtraImport": true,
        "detail": "aiida.common",
        "documentation": {}
    },
    {
        "label": "datastructures",
        "importPath": "aiida.common",
        "description": "aiida.common",
        "isExtraImport": true,
        "detail": "aiida.common",
        "documentation": {}
    },
    {
        "label": "exceptions",
        "importPath": "aiida.common",
        "description": "aiida.common",
        "isExtraImport": true,
        "detail": "aiida.common",
        "documentation": {}
    },
    {
        "label": "exceptions",
        "importPath": "aiida.common",
        "description": "aiida.common",
        "isExtraImport": true,
        "detail": "aiida.common",
        "documentation": {}
    },
    {
        "label": "exceptions",
        "importPath": "aiida.common",
        "description": "aiida.common",
        "isExtraImport": true,
        "detail": "aiida.common",
        "documentation": {}
    },
    {
        "label": "AIIDA_LOGGER",
        "importPath": "aiida.common",
        "description": "aiida.common",
        "isExtraImport": true,
        "detail": "aiida.common",
        "documentation": {}
    },
    {
        "label": "exceptions",
        "importPath": "aiida.common",
        "description": "aiida.common",
        "isExtraImport": true,
        "detail": "aiida.common",
        "documentation": {}
    },
    {
        "label": "AIIDA_LOGGER",
        "importPath": "aiida.common",
        "description": "aiida.common",
        "isExtraImport": true,
        "detail": "aiida.common",
        "documentation": {}
    },
    {
        "label": "AttributeDict",
        "importPath": "aiida.common",
        "description": "aiida.common",
        "isExtraImport": true,
        "detail": "aiida.common",
        "documentation": {}
    },
    {
        "label": "exceptions",
        "importPath": "aiida.common",
        "description": "aiida.common",
        "isExtraImport": true,
        "detail": "aiida.common",
        "documentation": {}
    },
    {
        "label": "AttributeDict",
        "importPath": "aiida.common",
        "description": "aiida.common",
        "isExtraImport": true,
        "detail": "aiida.common",
        "documentation": {}
    },
    {
        "label": "AttributeDict",
        "importPath": "aiida.common",
        "description": "aiida.common",
        "isExtraImport": true,
        "detail": "aiida.common",
        "documentation": {}
    },
    {
        "label": "AttributeDict",
        "importPath": "aiida.common",
        "description": "aiida.common",
        "isExtraImport": true,
        "detail": "aiida.common",
        "documentation": {}
    },
    {
        "label": "AttributeDict",
        "importPath": "aiida.common",
        "description": "aiida.common",
        "isExtraImport": true,
        "detail": "aiida.common",
        "documentation": {}
    },
    {
        "label": "AttributeDict",
        "importPath": "aiida.common",
        "description": "aiida.common",
        "isExtraImport": true,
        "detail": "aiida.common",
        "documentation": {}
    },
    {
        "label": "exceptions",
        "importPath": "aiida.common",
        "description": "aiida.common",
        "isExtraImport": true,
        "detail": "aiida.common",
        "documentation": {}
    },
    {
        "label": "AttributeDict",
        "importPath": "aiida.common",
        "description": "aiida.common",
        "isExtraImport": true,
        "detail": "aiida.common",
        "documentation": {}
    },
    {
        "label": "exceptions",
        "importPath": "aiida.common",
        "description": "aiida.common",
        "isExtraImport": true,
        "detail": "aiida.common",
        "documentation": {}
    },
    {
        "label": "AttributeDict",
        "importPath": "aiida.common",
        "description": "aiida.common",
        "isExtraImport": true,
        "detail": "aiida.common",
        "documentation": {}
    },
    {
        "label": "LinkType",
        "importPath": "aiida.common",
        "description": "aiida.common",
        "isExtraImport": true,
        "detail": "aiida.common",
        "documentation": {}
    },
    {
        "label": "AttributeDict",
        "importPath": "aiida.common",
        "description": "aiida.common",
        "isExtraImport": true,
        "detail": "aiida.common",
        "documentation": {}
    },
    {
        "label": "AttributeDict",
        "importPath": "aiida.common",
        "description": "aiida.common",
        "isExtraImport": true,
        "detail": "aiida.common",
        "documentation": {}
    },
    {
        "label": "AttributeDict",
        "importPath": "aiida.common",
        "description": "aiida.common",
        "isExtraImport": true,
        "detail": "aiida.common",
        "documentation": {}
    },
    {
        "label": "BaseCalculation",
        "importPath": "aiida_mobility.calculations",
        "description": "aiida_mobility.calculations",
        "isExtraImport": true,
        "detail": "aiida_mobility.calculations",
        "documentation": {}
    },
    {
        "label": "BaseCalculation",
        "importPath": "aiida_mobility.calculations",
        "description": "aiida_mobility.calculations",
        "isExtraImport": true,
        "detail": "aiida_mobility.calculations",
        "documentation": {}
    },
    {
        "label": "convert_input_to_namelist_entry",
        "importPath": "aiida_quantumespresso.utils.convert",
        "description": "aiida_quantumespresso.utils.convert",
        "isExtraImport": true,
        "detail": "aiida_quantumespresso.utils.convert",
        "documentation": {}
    },
    {
        "label": "CalcJob",
        "importPath": "aiida_quantumespresso.calculations.base",
        "description": "aiida_quantumespresso.calculations.base",
        "isExtraImport": true,
        "detail": "aiida_quantumespresso.calculations.base",
        "documentation": {}
    },
    {
        "label": "QE2pertParser",
        "importPath": "aiida_mobility.parsers.data_parser.qe2pert_parser",
        "description": "aiida_mobility.parsers.data_parser.qe2pert_parser",
        "isExtraImport": true,
        "detail": "aiida_mobility.parsers.data_parser.qe2pert_parser",
        "documentation": {}
    },
    {
        "label": "click",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "click",
        "description": "click",
        "detail": "click",
        "documentation": {}
    },
    {
        "label": "NotExistent",
        "importPath": "aiida.common.exceptions",
        "description": "aiida.common.exceptions",
        "isExtraImport": true,
        "detail": "aiida.common.exceptions",
        "documentation": {}
    },
    {
        "label": "NotExistent",
        "importPath": "aiida.common.exceptions",
        "description": "aiida.common.exceptions",
        "isExtraImport": true,
        "detail": "aiida.common.exceptions",
        "documentation": {}
    },
    {
        "label": "InputValidationError",
        "importPath": "aiida.common.exceptions",
        "description": "aiida.common.exceptions",
        "isExtraImport": true,
        "detail": "aiida.common.exceptions",
        "documentation": {}
    },
    {
        "label": "NotExistentKeyError",
        "importPath": "aiida.common.exceptions",
        "description": "aiida.common.exceptions",
        "isExtraImport": true,
        "detail": "aiida.common.exceptions",
        "documentation": {}
    },
    {
        "label": "NotExistent",
        "importPath": "aiida.common.exceptions",
        "description": "aiida.common.exceptions",
        "isExtraImport": true,
        "detail": "aiida.common.exceptions",
        "documentation": {}
    },
    {
        "label": "NotExistent",
        "importPath": "aiida.common.exceptions",
        "description": "aiida.common.exceptions",
        "isExtraImport": true,
        "detail": "aiida.common.exceptions",
        "documentation": {}
    },
    {
        "label": "default",
        "importPath": "ase.atoms",
        "description": "ase.atoms",
        "isExtraImport": true,
        "detail": "ase.atoms",
        "documentation": {}
    },
    {
        "label": "default",
        "importPath": "ase.atoms",
        "description": "ase.atoms",
        "isExtraImport": true,
        "detail": "ase.atoms",
        "documentation": {}
    },
    {
        "label": "default",
        "importPath": "ase.atoms",
        "description": "ase.atoms",
        "isExtraImport": true,
        "detail": "ase.atoms",
        "documentation": {}
    },
    {
        "label": "types",
        "importPath": "aiida.cmdline.params",
        "description": "aiida.cmdline.params",
        "isExtraImport": true,
        "detail": "aiida.cmdline.params",
        "documentation": {}
    },
    {
        "label": "options",
        "importPath": "aiida.cmdline.params",
        "description": "aiida.cmdline.params",
        "isExtraImport": true,
        "detail": "aiida.cmdline.params",
        "documentation": {}
    },
    {
        "label": "options",
        "importPath": "aiida.cmdline.params",
        "description": "aiida.cmdline.params",
        "isExtraImport": true,
        "detail": "aiida.cmdline.params",
        "documentation": {}
    },
    {
        "label": "OverridableOption",
        "importPath": "aiida.cmdline.params.options",
        "description": "aiida.cmdline.params.options",
        "isExtraImport": true,
        "detail": "aiida.cmdline.params.options",
        "documentation": {}
    },
    {
        "label": "decorators",
        "importPath": "aiida.cmdline.utils",
        "description": "aiida.cmdline.utils",
        "isExtraImport": true,
        "detail": "aiida.cmdline.utils",
        "documentation": {}
    },
    {
        "label": "decorators",
        "importPath": "aiida.cmdline.utils",
        "description": "aiida.cmdline.utils",
        "isExtraImport": true,
        "detail": "aiida.cmdline.utils",
        "documentation": {}
    },
    {
        "label": "decorators",
        "importPath": "aiida.cmdline.utils",
        "description": "aiida.cmdline.utils",
        "isExtraImport": true,
        "detail": "aiida.cmdline.utils",
        "documentation": {}
    },
    {
        "label": "decorators",
        "importPath": "aiida.cmdline.utils",
        "description": "aiida.cmdline.utils",
        "isExtraImport": true,
        "detail": "aiida.cmdline.utils",
        "documentation": {}
    },
    {
        "label": "decorators",
        "importPath": "aiida.cmdline.utils",
        "description": "aiida.cmdline.utils",
        "isExtraImport": true,
        "detail": "aiida.cmdline.utils",
        "documentation": {}
    },
    {
        "label": "decorators",
        "importPath": "aiida.cmdline.utils",
        "description": "aiida.cmdline.utils",
        "isExtraImport": true,
        "detail": "aiida.cmdline.utils",
        "documentation": {}
    },
    {
        "label": "load_node",
        "importPath": "aiida.orm.utils",
        "description": "aiida.orm.utils",
        "isExtraImport": true,
        "detail": "aiida.orm.utils",
        "documentation": {}
    },
    {
        "label": "load_node",
        "importPath": "aiida.orm.utils",
        "description": "aiida.orm.utils",
        "isExtraImport": true,
        "detail": "aiida.orm.utils",
        "documentation": {}
    },
    {
        "label": "load_node",
        "importPath": "aiida.orm.utils",
        "description": "aiida.orm.utils",
        "isExtraImport": true,
        "detail": "aiida.orm.utils",
        "documentation": {}
    },
    {
        "label": "load_node",
        "importPath": "aiida.orm.utils",
        "description": "aiida.orm.utils",
        "isExtraImport": true,
        "detail": "aiida.orm.utils",
        "documentation": {}
    },
    {
        "label": "load_node",
        "importPath": "aiida.orm.utils",
        "description": "aiida.orm.utils",
        "isExtraImport": true,
        "detail": "aiida.orm.utils",
        "documentation": {}
    },
    {
        "label": "WorkflowFactory",
        "importPath": "aiida.plugins",
        "description": "aiida.plugins",
        "isExtraImport": true,
        "detail": "aiida.plugins",
        "documentation": {}
    },
    {
        "label": "CalculationFactory",
        "importPath": "aiida.plugins",
        "description": "aiida.plugins",
        "isExtraImport": true,
        "detail": "aiida.plugins",
        "documentation": {}
    },
    {
        "label": "WorkflowFactory",
        "importPath": "aiida.plugins",
        "description": "aiida.plugins",
        "isExtraImport": true,
        "detail": "aiida.plugins",
        "documentation": {}
    },
    {
        "label": "WorkflowFactory",
        "importPath": "aiida.plugins",
        "description": "aiida.plugins",
        "isExtraImport": true,
        "detail": "aiida.plugins",
        "documentation": {}
    },
    {
        "label": "CalculationFactory",
        "importPath": "aiida.plugins",
        "description": "aiida.plugins",
        "isExtraImport": true,
        "detail": "aiida.plugins",
        "documentation": {}
    },
    {
        "label": "GroupFactory",
        "importPath": "aiida.plugins",
        "description": "aiida.plugins",
        "isExtraImport": true,
        "detail": "aiida.plugins",
        "documentation": {}
    },
    {
        "label": "CalculationFactory",
        "importPath": "aiida.plugins",
        "description": "aiida.plugins",
        "isExtraImport": true,
        "detail": "aiida.plugins",
        "documentation": {}
    },
    {
        "label": "WorkflowFactory",
        "importPath": "aiida.plugins",
        "description": "aiida.plugins",
        "isExtraImport": true,
        "detail": "aiida.plugins",
        "documentation": {}
    },
    {
        "label": "PhBandsWorkChain",
        "importPath": "aiida_mobility.workflows.ph.bands",
        "description": "aiida_mobility.workflows.ph.bands",
        "isExtraImport": true,
        "detail": "aiida_mobility.workflows.ph.bands",
        "documentation": {}
    },
    {
        "label": "PhBandsWorkChain",
        "importPath": "aiida_mobility.workflows.ph.bands",
        "description": "aiida_mobility.workflows.ph.bands",
        "isExtraImport": true,
        "detail": "aiida_mobility.workflows.ph.bands",
        "documentation": {}
    },
    {
        "label": "PhBandsWorkChain",
        "importPath": "aiida_mobility.workflows.ph.bands",
        "description": "aiida_mobility.workflows.ph.bands",
        "isExtraImport": true,
        "detail": "aiida_mobility.workflows.ph.bands",
        "documentation": {}
    },
    {
        "label": "PwRelaxWorkChain",
        "importPath": "aiida_mobility.workflows.pw.relax",
        "description": "aiida_mobility.workflows.pw.relax",
        "isExtraImport": true,
        "detail": "aiida_mobility.workflows.pw.relax",
        "documentation": {}
    },
    {
        "label": "PwRelaxWorkChain",
        "importPath": "aiida_mobility.workflows.pw.relax",
        "description": "aiida_mobility.workflows.pw.relax",
        "isExtraImport": true,
        "detail": "aiida_mobility.workflows.pw.relax",
        "documentation": {}
    },
    {
        "label": "PwRelaxWorkChain",
        "importPath": "aiida_mobility.workflows.pw.relax",
        "description": "aiida_mobility.workflows.pw.relax",
        "isExtraImport": true,
        "detail": "aiida_mobility.workflows.pw.relax",
        "documentation": {}
    },
    {
        "label": "PwRelaxWorkChain",
        "importPath": "aiida_mobility.workflows.pw.relax",
        "description": "aiida_mobility.workflows.pw.relax",
        "isExtraImport": true,
        "detail": "aiida_mobility.workflows.pw.relax",
        "documentation": {}
    },
    {
        "label": "PwRelaxWorkChain",
        "importPath": "aiida_mobility.workflows.pw.relax",
        "description": "aiida_mobility.workflows.pw.relax",
        "isExtraImport": true,
        "detail": "aiida_mobility.workflows.pw.relax",
        "documentation": {}
    },
    {
        "label": "PwRelaxWorkChain",
        "importPath": "aiida_mobility.workflows.pw.relax",
        "description": "aiida_mobility.workflows.pw.relax",
        "isExtraImport": true,
        "detail": "aiida_mobility.workflows.pw.relax",
        "documentation": {}
    },
    {
        "label": "Wannier90BandsWorkChain",
        "importPath": "aiida_mobility.workflows.wannier.bands",
        "description": "aiida_mobility.workflows.wannier.bands",
        "isExtraImport": true,
        "detail": "aiida_mobility.workflows.wannier.bands",
        "documentation": {}
    },
    {
        "label": "Wannier90BandsWorkChain",
        "importPath": "aiida_mobility.workflows.wannier.bands",
        "description": "aiida_mobility.workflows.wannier.bands",
        "isExtraImport": true,
        "detail": "aiida_mobility.workflows.wannier.bands",
        "documentation": {}
    },
    {
        "label": "Wannier90BandsWorkChain",
        "importPath": "aiida_mobility.workflows.wannier.bands",
        "description": "aiida_mobility.workflows.wannier.bands",
        "isExtraImport": true,
        "detail": "aiida_mobility.workflows.wannier.bands",
        "documentation": {}
    },
    {
        "label": "Wannier90BandsWorkChain",
        "importPath": "aiida_mobility.workflows.wannier.bands",
        "description": "aiida_mobility.workflows.wannier.bands",
        "isExtraImport": true,
        "detail": "aiida_mobility.workflows.wannier.bands",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "importlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "importlib",
        "description": "importlib",
        "detail": "importlib",
        "documentation": {}
    },
    {
        "label": "PARAMETERS_SET",
        "importPath": "aiida_mobility.cli.utils.options",
        "description": "aiida_mobility.cli.utils.options",
        "isExtraImport": true,
        "detail": "aiida_mobility.cli.utils.options",
        "documentation": {}
    },
    {
        "label": "options",
        "importPath": "aiida_mobility.cli.utils",
        "description": "aiida_mobility.cli.utils",
        "isExtraImport": true,
        "detail": "aiida_mobility.cli.utils",
        "documentation": {}
    },
    {
        "label": "Parser",
        "importPath": "aiida.parsers.parser",
        "description": "aiida.parsers.parser",
        "isExtraImport": true,
        "detail": "aiida.parsers.parser",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "QE2PertCalculation",
        "importPath": "aiida_mobility.calculations.qe2pert",
        "description": "aiida_mobility.calculations.qe2pert",
        "isExtraImport": true,
        "detail": "aiida_mobility.calculations.qe2pert",
        "documentation": {}
    },
    {
        "label": "QE2PertCalculation",
        "importPath": "aiida_mobility.calculations.qe2pert",
        "description": "aiida_mobility.calculations.qe2pert",
        "isExtraImport": true,
        "detail": "aiida_mobility.calculations.qe2pert",
        "documentation": {}
    },
    {
        "label": "argparse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "argparse",
        "description": "argparse",
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "get_number_of_electrons_from_upf",
        "importPath": "aiida_wannier90_workflows.utils.upf",
        "description": "aiida_wannier90_workflows.utils.upf",
        "isExtraImport": true,
        "detail": "aiida_wannier90_workflows.utils.upf",
        "documentation": {}
    },
    {
        "label": "get_number_of_projections_from_upf",
        "importPath": "aiida_wannier90_workflows.utils.upf",
        "description": "aiida_wannier90_workflows.utils.upf",
        "isExtraImport": true,
        "detail": "aiida_wannier90_workflows.utils.upf",
        "documentation": {}
    },
    {
        "label": "pythtb",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pythtb",
        "description": "pythtb",
        "detail": "pythtb",
        "documentation": {}
    },
    {
        "label": "tempfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tempfile",
        "description": "tempfile",
        "detail": "tempfile",
        "documentation": {}
    },
    {
        "label": "shutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shutil",
        "description": "shutil",
        "detail": "shutil",
        "documentation": {}
    },
    {
        "label": "raw_wout_parser",
        "importPath": "aiida_wannier90.parsers",
        "description": "aiida_wannier90.parsers",
        "isExtraImport": true,
        "detail": "aiida_wannier90.parsers",
        "documentation": {}
    },
    {
        "label": "erfc_scdm",
        "importPath": "aiida_mobility.utils.scdm",
        "description": "aiida_mobility.utils.scdm",
        "isExtraImport": true,
        "detail": "aiida_mobility.utils.scdm",
        "documentation": {}
    },
    {
        "label": "fit_scdm_mu_sigma_aiida",
        "importPath": "aiida_mobility.utils.scdm",
        "description": "aiida_mobility.utils.scdm",
        "isExtraImport": true,
        "detail": "aiida_mobility.utils.scdm",
        "documentation": {}
    },
    {
        "label": "fit_scdm_mu_sigma_aiida",
        "importPath": "aiida_mobility.utils.scdm",
        "description": "aiida_mobility.utils.scdm",
        "isExtraImport": true,
        "detail": "aiida_mobility.utils.scdm",
        "documentation": {}
    },
    {
        "label": "matplotlib.pyplot",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.pyplot",
        "description": "matplotlib.pyplot",
        "detail": "matplotlib.pyplot",
        "documentation": {}
    },
    {
        "label": "plot",
        "importPath": "matplotlib.pyplot",
        "description": "matplotlib.pyplot",
        "isExtraImport": true,
        "detail": "matplotlib.pyplot",
        "documentation": {}
    },
    {
        "label": "show",
        "importPath": "matplotlib.pyplot",
        "description": "matplotlib.pyplot",
        "isExtraImport": true,
        "detail": "matplotlib.pyplot",
        "documentation": {}
    },
    {
        "label": "figure",
        "importPath": "matplotlib.pyplot",
        "description": "matplotlib.pyplot",
        "isExtraImport": true,
        "detail": "matplotlib.pyplot",
        "documentation": {}
    },
    {
        "label": "savefig",
        "importPath": "matplotlib.pyplot",
        "description": "matplotlib.pyplot",
        "isExtraImport": true,
        "detail": "matplotlib.pyplot",
        "documentation": {}
    },
    {
        "label": "xticks",
        "importPath": "matplotlib.pyplot",
        "description": "matplotlib.pyplot",
        "isExtraImport": true,
        "detail": "matplotlib.pyplot",
        "documentation": {}
    },
    {
        "label": "deepcopy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "deepcopy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "typing",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "typing",
        "description": "typing",
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "erfc",
        "importPath": "scipy.special",
        "description": "scipy.special",
        "isExtraImport": true,
        "detail": "scipy.special",
        "documentation": {}
    },
    {
        "label": "curve_fit",
        "importPath": "scipy.optimize",
        "description": "scipy.optimize",
        "isExtraImport": true,
        "detail": "scipy.optimize",
        "documentation": {}
    },
    {
        "label": "xml.etree.ElementTree",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "xml.etree.ElementTree",
        "description": "xml.etree.ElementTree",
        "detail": "xml.etree.ElementTree",
        "documentation": {}
    },
    {
        "label": "hashlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "hashlib",
        "description": "hashlib",
        "detail": "hashlib",
        "documentation": {}
    },
    {
        "label": "seekpath_structure_analysis",
        "importPath": "aiida_quantumespresso.calculations.functions.seekpath_structure_analysis",
        "description": "aiida_quantumespresso.calculations.functions.seekpath_structure_analysis",
        "isExtraImport": true,
        "detail": "aiida_quantumespresso.calculations.functions.seekpath_structure_analysis",
        "documentation": {}
    },
    {
        "label": "seekpath_structure_analysis",
        "importPath": "aiida_quantumespresso.calculations.functions.seekpath_structure_analysis",
        "description": "aiida_quantumespresso.calculations.functions.seekpath_structure_analysis",
        "isExtraImport": true,
        "detail": "aiida_quantumespresso.calculations.functions.seekpath_structure_analysis",
        "documentation": {}
    },
    {
        "label": "seekpath_structure_analysis",
        "importPath": "aiida_quantumespresso.calculations.functions.seekpath_structure_analysis",
        "description": "aiida_quantumespresso.calculations.functions.seekpath_structure_analysis",
        "isExtraImport": true,
        "detail": "aiida_quantumespresso.calculations.functions.seekpath_structure_analysis",
        "documentation": {}
    },
    {
        "label": "seekpath_structure_analysis",
        "importPath": "aiida_quantumespresso.calculations.functions.seekpath_structure_analysis",
        "description": "aiida_quantumespresso.calculations.functions.seekpath_structure_analysis",
        "isExtraImport": true,
        "detail": "aiida_quantumespresso.calculations.functions.seekpath_structure_analysis",
        "documentation": {}
    },
    {
        "label": "prepare_process_inputs",
        "importPath": "aiida_quantumespresso.utils.mapping",
        "description": "aiida_quantumespresso.utils.mapping",
        "isExtraImport": true,
        "detail": "aiida_quantumespresso.utils.mapping",
        "documentation": {}
    },
    {
        "label": "prepare_process_inputs",
        "importPath": "aiida_quantumespresso.utils.mapping",
        "description": "aiida_quantumespresso.utils.mapping",
        "isExtraImport": true,
        "detail": "aiida_quantumespresso.utils.mapping",
        "documentation": {}
    },
    {
        "label": "prepare_process_inputs",
        "importPath": "aiida_quantumespresso.utils.mapping",
        "description": "aiida_quantumespresso.utils.mapping",
        "isExtraImport": true,
        "detail": "aiida_quantumespresso.utils.mapping",
        "documentation": {}
    },
    {
        "label": "prepare_process_inputs",
        "importPath": "aiida_quantumespresso.utils.mapping",
        "description": "aiida_quantumespresso.utils.mapping",
        "isExtraImport": true,
        "detail": "aiida_quantumespresso.utils.mapping",
        "documentation": {}
    },
    {
        "label": "update_mapping",
        "importPath": "aiida_quantumespresso.utils.mapping",
        "description": "aiida_quantumespresso.utils.mapping",
        "isExtraImport": true,
        "detail": "aiida_quantumespresso.utils.mapping",
        "documentation": {}
    },
    {
        "label": "prepare_process_inputs",
        "importPath": "aiida_quantumespresso.utils.mapping",
        "description": "aiida_quantumespresso.utils.mapping",
        "isExtraImport": true,
        "detail": "aiida_quantumespresso.utils.mapping",
        "documentation": {}
    },
    {
        "label": "prepare_process_inputs",
        "importPath": "aiida_quantumespresso.utils.mapping",
        "description": "aiida_quantumespresso.utils.mapping",
        "isExtraImport": true,
        "detail": "aiida_quantumespresso.utils.mapping",
        "documentation": {}
    },
    {
        "label": "prepare_process_inputs",
        "importPath": "aiida_quantumespresso.utils.mapping",
        "description": "aiida_quantumespresso.utils.mapping",
        "isExtraImport": true,
        "detail": "aiida_quantumespresso.utils.mapping",
        "documentation": {}
    },
    {
        "label": "prepare_process_inputs",
        "importPath": "aiida_quantumespresso.utils.mapping",
        "description": "aiida_quantumespresso.utils.mapping",
        "isExtraImport": true,
        "detail": "aiida_quantumespresso.utils.mapping",
        "documentation": {}
    },
    {
        "label": "prepare_process_inputs",
        "importPath": "aiida_quantumespresso.utils.mapping",
        "description": "aiida_quantumespresso.utils.mapping",
        "isExtraImport": true,
        "detail": "aiida_quantumespresso.utils.mapping",
        "documentation": {}
    },
    {
        "label": "PwBaseWorkChain",
        "importPath": "aiida_mobility.workflows.pw.base",
        "description": "aiida_mobility.workflows.pw.base",
        "isExtraImport": true,
        "detail": "aiida_mobility.workflows.pw.base",
        "documentation": {}
    },
    {
        "label": "PwBaseWorkChain",
        "importPath": "aiida_mobility.workflows.pw.base",
        "description": "aiida_mobility.workflows.pw.base",
        "isExtraImport": true,
        "detail": "aiida_mobility.workflows.pw.base",
        "documentation": {}
    },
    {
        "label": "PwBaseWorkChain",
        "importPath": "aiida_mobility.workflows.pw.base",
        "description": "aiida_mobility.workflows.pw.base",
        "isExtraImport": true,
        "detail": "aiida_mobility.workflows.pw.base",
        "documentation": {}
    },
    {
        "label": "PwBaseWorkChain",
        "importPath": "aiida_mobility.workflows.pw.base",
        "description": "aiida_mobility.workflows.pw.base",
        "isExtraImport": true,
        "detail": "aiida_mobility.workflows.pw.base",
        "documentation": {}
    },
    {
        "label": "PwBaseWorkChain",
        "importPath": "aiida_mobility.workflows.pw.base",
        "description": "aiida_mobility.workflows.pw.base",
        "isExtraImport": true,
        "detail": "aiida_mobility.workflows.pw.base",
        "documentation": {}
    },
    {
        "label": "PwBaseWorkChain",
        "importPath": "aiida_mobility.workflows.pw.base",
        "description": "aiida_mobility.workflows.pw.base",
        "isExtraImport": true,
        "detail": "aiida_mobility.workflows.pw.base",
        "documentation": {}
    },
    {
        "label": "PhBaseWorkChain",
        "importPath": "aiida_mobility.workflows.ph.base",
        "description": "aiida_mobility.workflows.ph.base",
        "isExtraImport": true,
        "detail": "aiida_mobility.workflows.ph.base",
        "documentation": {}
    },
    {
        "label": "PhBaseWorkChain",
        "importPath": "aiida_mobility.workflows.ph.base",
        "description": "aiida_mobility.workflows.ph.base",
        "isExtraImport": true,
        "detail": "aiida_mobility.workflows.ph.base",
        "documentation": {}
    },
    {
        "label": "PhBaseWorkChain",
        "importPath": "aiida_mobility.workflows.ph.base",
        "description": "aiida_mobility.workflows.ph.base",
        "isExtraImport": true,
        "detail": "aiida_mobility.workflows.ph.base",
        "documentation": {}
    },
    {
        "label": "Q2rBaseWorkChain",
        "importPath": "aiida_quantumespresso.workflows.q2r.base",
        "description": "aiida_quantumespresso.workflows.q2r.base",
        "isExtraImport": true,
        "detail": "aiida_quantumespresso.workflows.q2r.base",
        "documentation": {}
    },
    {
        "label": "Q2rBaseWorkChain",
        "importPath": "aiida_quantumespresso.workflows.q2r.base",
        "description": "aiida_quantumespresso.workflows.q2r.base",
        "isExtraImport": true,
        "detail": "aiida_quantumespresso.workflows.q2r.base",
        "documentation": {}
    },
    {
        "label": "Q2rBaseWorkChain",
        "importPath": "aiida_quantumespresso.workflows.q2r.base",
        "description": "aiida_quantumespresso.workflows.q2r.base",
        "isExtraImport": true,
        "detail": "aiida_quantumespresso.workflows.q2r.base",
        "documentation": {}
    },
    {
        "label": "MatdynBaseWorkChain",
        "importPath": "aiida_quantumespresso.workflows.matdyn.base",
        "description": "aiida_quantumespresso.workflows.matdyn.base",
        "isExtraImport": true,
        "detail": "aiida_quantumespresso.workflows.matdyn.base",
        "documentation": {}
    },
    {
        "label": "MatdynBaseWorkChain",
        "importPath": "aiida_quantumespresso.workflows.matdyn.base",
        "description": "aiida_quantumespresso.workflows.matdyn.base",
        "isExtraImport": true,
        "detail": "aiida_quantumespresso.workflows.matdyn.base",
        "documentation": {}
    },
    {
        "label": "MatdynBaseWorkChain",
        "importPath": "aiida_quantumespresso.workflows.matdyn.base",
        "description": "aiida_quantumespresso.workflows.matdyn.base",
        "isExtraImport": true,
        "detail": "aiida_quantumespresso.workflows.matdyn.base",
        "documentation": {}
    },
    {
        "label": "AttributeDict",
        "importPath": "aiida.common.extendeddicts",
        "description": "aiida.common.extendeddicts",
        "isExtraImport": true,
        "detail": "aiida.common.extendeddicts",
        "documentation": {}
    },
    {
        "label": "AttributeDict",
        "importPath": "aiida.common.extendeddicts",
        "description": "aiida.common.extendeddicts",
        "isExtraImport": true,
        "detail": "aiida.common.extendeddicts",
        "documentation": {}
    },
    {
        "label": "AttributeDict",
        "importPath": "aiida.common.extendeddicts",
        "description": "aiida.common.extendeddicts",
        "isExtraImport": true,
        "detail": "aiida.common.extendeddicts",
        "documentation": {}
    },
    {
        "label": "ToContext",
        "importPath": "aiida.engine.processes.workchains.context",
        "description": "aiida.engine.processes.workchains.context",
        "isExtraImport": true,
        "detail": "aiida.engine.processes.workchains.context",
        "documentation": {}
    },
    {
        "label": "ToContext",
        "importPath": "aiida.engine.processes.workchains.context",
        "description": "aiida.engine.processes.workchains.context",
        "isExtraImport": true,
        "detail": "aiida.engine.processes.workchains.context",
        "documentation": {}
    },
    {
        "label": "WorkChain",
        "importPath": "aiida.engine.processes.workchains.workchain",
        "description": "aiida.engine.processes.workchains.workchain",
        "isExtraImport": true,
        "detail": "aiida.engine.processes.workchains.workchain",
        "documentation": {}
    },
    {
        "label": "WorkChain",
        "importPath": "aiida.engine.processes.workchains.workchain",
        "description": "aiida.engine.processes.workchains.workchain",
        "isExtraImport": true,
        "detail": "aiida.engine.processes.workchains.workchain",
        "documentation": {}
    },
    {
        "label": "true",
        "importPath": "sqlalchemy.sql.expression",
        "description": "sqlalchemy.sql.expression",
        "isExtraImport": true,
        "detail": "sqlalchemy.sql.expression",
        "documentation": {}
    },
    {
        "label": "PerturboCalculation",
        "importPath": "aiida_mobility.calculations.perturbo",
        "description": "aiida_mobility.calculations.perturbo",
        "isExtraImport": true,
        "detail": "aiida_mobility.calculations.perturbo",
        "documentation": {}
    },
    {
        "label": "if_",
        "importPath": "plumpy.workchains",
        "description": "plumpy.workchains",
        "isExtraImport": true,
        "detail": "plumpy.workchains",
        "documentation": {}
    },
    {
        "label": "PhRecoverCalculation",
        "importPath": "aiida_mobility.calculations.ph_recover",
        "description": "aiida_mobility.calculations.ph_recover",
        "isExtraImport": true,
        "detail": "aiida_mobility.calculations.ph_recover",
        "documentation": {}
    },
    {
        "label": "BaseRestartWorkChain",
        "importPath": "aiida_mobility.workflows",
        "description": "aiida_mobility.workflows",
        "isExtraImport": true,
        "detail": "aiida_mobility.workflows",
        "documentation": {}
    },
    {
        "label": "get_pseudos_from_structure",
        "importPath": "aiida.orm.nodes.data.upf",
        "description": "aiida.orm.nodes.data.upf",
        "isExtraImport": true,
        "detail": "aiida.orm.nodes.data.upf",
        "documentation": {}
    },
    {
        "label": "get_pseudos_from_structure",
        "importPath": "aiida.orm.nodes.data.upf",
        "description": "aiida.orm.nodes.data.upf",
        "isExtraImport": true,
        "detail": "aiida.orm.nodes.data.upf",
        "documentation": {}
    },
    {
        "label": "ProtocolManager",
        "importPath": "aiida_mobility.utils.protocols.pw",
        "description": "aiida_mobility.utils.protocols.pw",
        "isExtraImport": true,
        "detail": "aiida_mobility.utils.protocols.pw",
        "documentation": {}
    },
    {
        "label": "ProtocolManager",
        "importPath": "aiida_mobility.utils.protocols.pw",
        "description": "aiida_mobility.utils.protocols.pw",
        "isExtraImport": true,
        "detail": "aiida_mobility.utils.protocols.pw",
        "documentation": {}
    },
    {
        "label": "ProtocolManager",
        "importPath": "aiida_mobility.utils.protocols.pw",
        "description": "aiida_mobility.utils.protocols.pw",
        "isExtraImport": true,
        "detail": "aiida_mobility.utils.protocols.pw",
        "documentation": {}
    },
    {
        "label": "get_pseudos_from_dict",
        "importPath": "aiida_quantumespresso.utils.pseudopotential",
        "description": "aiida_quantumespresso.utils.pseudopotential",
        "isExtraImport": true,
        "detail": "aiida_quantumespresso.utils.pseudopotential",
        "documentation": {}
    },
    {
        "label": "validate_and_prepare_pseudos_inputs",
        "importPath": "aiida_quantumespresso.utils.pseudopotential",
        "description": "aiida_quantumespresso.utils.pseudopotential",
        "isExtraImport": true,
        "detail": "aiida_quantumespresso.utils.pseudopotential",
        "documentation": {}
    },
    {
        "label": "get_pseudos_from_dict",
        "importPath": "aiida_quantumespresso.utils.pseudopotential",
        "description": "aiida_quantumespresso.utils.pseudopotential",
        "isExtraImport": true,
        "detail": "aiida_quantumespresso.utils.pseudopotential",
        "documentation": {}
    },
    {
        "label": "get_pseudos_from_dict",
        "importPath": "aiida_quantumespresso.utils.pseudopotential",
        "description": "aiida_quantumespresso.utils.pseudopotential",
        "isExtraImport": true,
        "detail": "aiida_quantumespresso.utils.pseudopotential",
        "documentation": {}
    },
    {
        "label": "get_default_options",
        "importPath": "aiida_quantumespresso.utils.resources",
        "description": "aiida_quantumespresso.utils.resources",
        "isExtraImport": true,
        "detail": "aiida_quantumespresso.utils.resources",
        "documentation": {}
    },
    {
        "label": "get_default_options",
        "importPath": "aiida_quantumespresso.utils.resources",
        "description": "aiida_quantumespresso.utils.resources",
        "isExtraImport": true,
        "detail": "aiida_quantumespresso.utils.resources",
        "documentation": {}
    },
    {
        "label": "get_pw_parallelization_parameters",
        "importPath": "aiida_quantumespresso.utils.resources",
        "description": "aiida_quantumespresso.utils.resources",
        "isExtraImport": true,
        "detail": "aiida_quantumespresso.utils.resources",
        "documentation": {}
    },
    {
        "label": "cmdline_remove_npools",
        "importPath": "aiida_quantumespresso.utils.resources",
        "description": "aiida_quantumespresso.utils.resources",
        "isExtraImport": true,
        "detail": "aiida_quantumespresso.utils.resources",
        "documentation": {}
    },
    {
        "label": "create_scheduler_resources",
        "importPath": "aiida_quantumespresso.utils.resources",
        "description": "aiida_quantumespresso.utils.resources",
        "isExtraImport": true,
        "detail": "aiida_quantumespresso.utils.resources",
        "documentation": {}
    },
    {
        "label": "PwBandsWorkChain",
        "importPath": "aiida_mobility.workflows.pw.bands",
        "description": "aiida_mobility.workflows.pw.bands",
        "isExtraImport": true,
        "detail": "aiida_mobility.workflows.pw.bands",
        "documentation": {}
    },
    {
        "label": "ProtocolMixin",
        "importPath": "aiida_quantumespresso.workflows.protocols.utils",
        "description": "aiida_quantumespresso.workflows.protocols.utils",
        "isExtraImport": true,
        "detail": "aiida_quantumespresso.workflows.protocols.utils",
        "documentation": {}
    },
    {
        "label": "ProtocolMixin",
        "importPath": "aiida_quantumespresso.workflows.protocols.utils",
        "description": "aiida_quantumespresso.workflows.protocols.utils",
        "isExtraImport": true,
        "detail": "aiida_quantumespresso.workflows.protocols.utils",
        "documentation": {}
    },
    {
        "label": "ProtocolMixin",
        "importPath": "aiida_quantumespresso.workflows.protocols.utils",
        "description": "aiida_quantumespresso.workflows.protocols.utils",
        "isExtraImport": true,
        "detail": "aiida_quantumespresso.workflows.protocols.utils",
        "documentation": {}
    },
    {
        "label": "type_check",
        "importPath": "aiida.common.lang",
        "description": "aiida.common.lang",
        "isExtraImport": true,
        "detail": "aiida.common.lang",
        "documentation": {}
    },
    {
        "label": "type_check",
        "importPath": "aiida.common.lang",
        "description": "aiida.common.lang",
        "isExtraImport": true,
        "detail": "aiida.common.lang",
        "documentation": {}
    },
    {
        "label": "ElectronicType",
        "importPath": "aiida_quantumespresso.common.types",
        "description": "aiida_quantumespresso.common.types",
        "isExtraImport": true,
        "detail": "aiida_quantumespresso.common.types",
        "documentation": {}
    },
    {
        "label": "SpinType",
        "importPath": "aiida_quantumespresso.common.types",
        "description": "aiida_quantumespresso.common.types",
        "isExtraImport": true,
        "detail": "aiida_quantumespresso.common.types",
        "documentation": {}
    },
    {
        "label": "RelaxType",
        "importPath": "aiida_quantumespresso.common.types",
        "description": "aiida_quantumespresso.common.types",
        "isExtraImport": true,
        "detail": "aiida_quantumespresso.common.types",
        "documentation": {}
    },
    {
        "label": "pw",
        "importPath": "aiida_quantumespresso.utils.defaults.calculation",
        "description": "aiida_quantumespresso.utils.defaults.calculation",
        "isExtraImport": true,
        "detail": "aiida_quantumespresso.utils.defaults.calculation",
        "documentation": {}
    },
    {
        "label": "get_number_of_electrons",
        "importPath": "aiida_mobility.utils.upf",
        "description": "aiida_mobility.utils.upf",
        "isExtraImport": true,
        "detail": "aiida_mobility.utils.upf",
        "documentation": {}
    },
    {
        "label": "get_number_of_projections",
        "importPath": "aiida_mobility.utils.upf",
        "description": "aiida_mobility.utils.upf",
        "isExtraImport": true,
        "detail": "aiida_mobility.utils.upf",
        "documentation": {}
    },
    {
        "label": "get_wannier_number_of_bands",
        "importPath": "aiida_mobility.utils.upf",
        "description": "aiida_mobility.utils.upf",
        "isExtraImport": true,
        "detail": "aiida_mobility.utils.upf",
        "documentation": {}
    },
    {
        "label": "_load_pseudo_metadata",
        "importPath": "aiida_mobility.utils.upf",
        "description": "aiida_mobility.utils.upf",
        "isExtraImport": true,
        "detail": "aiida_mobility.utils.upf",
        "documentation": {}
    },
    {
        "label": "convert_kpoints_mesh_to_list",
        "importPath": "aiida_mobility.calculations.functions.kmesh",
        "description": "aiida_mobility.calculations.functions.kmesh",
        "isExtraImport": true,
        "detail": "aiida_mobility.calculations.functions.kmesh",
        "documentation": {}
    },
    {
        "label": "Wannier90Calculation",
        "importPath": "aiida_wannier90.calculations",
        "description": "aiida_wannier90.calculations",
        "isExtraImport": true,
        "detail": "aiida_wannier90.calculations",
        "documentation": {}
    },
    {
        "label": "Wannier90Calculation",
        "importPath": "aiida_wannier90.calculations",
        "description": "aiida_wannier90.calculations",
        "isExtraImport": true,
        "detail": "aiida_wannier90.calculations",
        "documentation": {}
    },
    {
        "label": "Wannier90Calculation",
        "importPath": "aiida_wannier90.calculations",
        "description": "aiida_wannier90.calculations",
        "isExtraImport": true,
        "detail": "aiida_wannier90.calculations",
        "documentation": {}
    },
    {
        "label": "WorkChain",
        "importPath": "aiida.engine.processes",
        "description": "aiida.engine.processes",
        "isExtraImport": true,
        "detail": "aiida.engine.processes",
        "documentation": {}
    },
    {
        "label": "ToContext",
        "importPath": "aiida.engine.processes",
        "description": "aiida.engine.processes",
        "isExtraImport": true,
        "detail": "aiida.engine.processes",
        "documentation": {}
    },
    {
        "label": "if_",
        "importPath": "aiida.engine.processes",
        "description": "aiida.engine.processes",
        "isExtraImport": true,
        "detail": "aiida.engine.processes",
        "documentation": {}
    },
    {
        "label": "calcfunction",
        "importPath": "aiida.engine.processes",
        "description": "aiida.engine.processes",
        "isExtraImport": true,
        "detail": "aiida.engine.processes",
        "documentation": {}
    },
    {
        "label": "calcfunction",
        "importPath": "aiida.engine.processes",
        "description": "aiida.engine.processes",
        "isExtraImport": true,
        "detail": "aiida.engine.processes",
        "documentation": {}
    },
    {
        "label": "WorkChain",
        "importPath": "aiida.engine.processes",
        "description": "aiida.engine.processes",
        "isExtraImport": true,
        "detail": "aiida.engine.processes",
        "documentation": {}
    },
    {
        "label": "ToContext",
        "importPath": "aiida.engine.processes",
        "description": "aiida.engine.processes",
        "isExtraImport": true,
        "detail": "aiida.engine.processes",
        "documentation": {}
    },
    {
        "label": "if_",
        "importPath": "aiida.engine.processes",
        "description": "aiida.engine.processes",
        "isExtraImport": true,
        "detail": "aiida.engine.processes",
        "documentation": {}
    },
    {
        "label": "ProjwfcCalculation",
        "importPath": "aiida_quantumespresso.calculations.projwfc",
        "description": "aiida_quantumespresso.calculations.projwfc",
        "isExtraImport": true,
        "detail": "aiida_quantumespresso.calculations.projwfc",
        "documentation": {}
    },
    {
        "label": "ProjwfcCalculation",
        "importPath": "aiida_quantumespresso.calculations.projwfc",
        "description": "aiida_quantumespresso.calculations.projwfc",
        "isExtraImport": true,
        "detail": "aiida_quantumespresso.calculations.projwfc",
        "documentation": {}
    },
    {
        "label": "Pw2wannier90Calculation",
        "importPath": "aiida_quantumespresso.calculations.pw2wannier90",
        "description": "aiida_quantumespresso.calculations.pw2wannier90",
        "isExtraImport": true,
        "detail": "aiida_quantumespresso.calculations.pw2wannier90",
        "documentation": {}
    },
    {
        "label": "Pw2wannier90Calculation",
        "importPath": "aiida_quantumespresso.calculations.pw2wannier90",
        "description": "aiida_quantumespresso.calculations.pw2wannier90",
        "isExtraImport": true,
        "detail": "aiida_quantumespresso.calculations.pw2wannier90",
        "documentation": {}
    },
    {
        "label": "Wannier90BaseWorkChain",
        "importPath": "aiida_mobility.workflows.wannier.base",
        "description": "aiida_mobility.workflows.wannier.base",
        "isExtraImport": true,
        "detail": "aiida_mobility.workflows.wannier.base",
        "documentation": {}
    },
    {
        "label": "PwBaseWorkChain",
        "importPath": "aiida_quantumespresso.workflows.pw.base",
        "description": "aiida_quantumespresso.workflows.pw.base",
        "isExtraImport": true,
        "detail": "aiida_quantumespresso.workflows.pw.base",
        "documentation": {}
    },
    {
        "label": "PwRelaxWorkChain",
        "importPath": "aiida_quantumespresso.workflows.pw.relax",
        "description": "aiida_quantumespresso.workflows.pw.relax",
        "isExtraImport": true,
        "detail": "aiida_quantumespresso.workflows.pw.relax",
        "documentation": {}
    },
    {
        "label": "Wannier90WorkChain",
        "importPath": "aiida_wannier90_workflows.workflows.wannier",
        "description": "aiida_wannier90_workflows.workflows.wannier",
        "isExtraImport": true,
        "detail": "aiida_wannier90_workflows.workflows.wannier",
        "documentation": {}
    },
    {
        "label": "OpengridCalculation",
        "importPath": "aiida_quantumespresso.calculations.opengrid",
        "description": "aiida_quantumespresso.calculations.opengrid",
        "isExtraImport": true,
        "detail": "aiida_quantumespresso.calculations.opengrid",
        "documentation": {}
    },
    {
        "label": "run_get_pk",
        "importPath": "aiida.engine.launch",
        "description": "aiida.engine.launch",
        "isExtraImport": true,
        "detail": "aiida.engine.launch",
        "documentation": {}
    },
    {
        "label": "submit",
        "importPath": "aiida.engine.launch",
        "description": "aiida.engine.launch",
        "isExtraImport": true,
        "detail": "aiida.engine.launch",
        "documentation": {}
    },
    {
        "label": "submit",
        "importPath": "aiida.engine.launch",
        "description": "aiida.engine.launch",
        "isExtraImport": true,
        "detail": "aiida.engine.launch",
        "documentation": {}
    },
    {
        "label": "run_get_pk",
        "importPath": "aiida.engine.launch",
        "description": "aiida.engine.launch",
        "isExtraImport": true,
        "detail": "aiida.engine.launch",
        "documentation": {}
    },
    {
        "label": "submit",
        "importPath": "aiida.engine.launch",
        "description": "aiida.engine.launch",
        "isExtraImport": true,
        "detail": "aiida.engine.launch",
        "documentation": {}
    },
    {
        "label": "run_get_pk",
        "importPath": "aiida.engine.launch",
        "description": "aiida.engine.launch",
        "isExtraImport": true,
        "detail": "aiida.engine.launch",
        "documentation": {}
    },
    {
        "label": "run_get_pk",
        "importPath": "aiida.engine.launch",
        "description": "aiida.engine.launch",
        "isExtraImport": true,
        "detail": "aiida.engine.launch",
        "documentation": {}
    },
    {
        "label": "submit",
        "importPath": "aiida.engine.launch",
        "description": "aiida.engine.launch",
        "isExtraImport": true,
        "detail": "aiida.engine.launch",
        "documentation": {}
    },
    {
        "label": "DataFactory",
        "importPath": "aiida.plugins.factories",
        "description": "aiida.plugins.factories",
        "isExtraImport": true,
        "detail": "aiida.plugins.factories",
        "documentation": {}
    },
    {
        "label": "MatdynWorkChain",
        "importPath": "aiida_mobility.workflows.matdyn.matdyn_workflow",
        "description": "aiida_mobility.workflows.matdyn.matdyn_workflow",
        "isExtraImport": true,
        "detail": "aiida_mobility.workflows.matdyn.matdyn_workflow",
        "documentation": {}
    },
    {
        "label": "PwBandStructureWorkChain",
        "importPath": "aiida_mobility.workflows.pw.band_structure",
        "description": "aiida_mobility.workflows.pw.band_structure",
        "isExtraImport": true,
        "detail": "aiida_mobility.workflows.pw.band_structure",
        "documentation": {}
    },
    {
        "label": "ase",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ase",
        "description": "ase",
        "detail": "ase",
        "documentation": {}
    },
    {
        "label": "setup",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "find_packages",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "convert_kpoints_mesh_to_list",
        "kind": 2,
        "importPath": "aiida_mobility.calculations.functions.kmesh",
        "description": "aiida_mobility.calculations.functions.kmesh",
        "peekOfCode": "def convert_kpoints_mesh_to_list(kmesh):\n    \"\"\"works just like `kmesh.pl` in Wannier90\n    :param kmesh: contains a N1 * N2 * N3 mesh\n    :type kmesh: aiida.orm.KpointsData\n    :raises AttributeError: if kmesh does not contains a mesh\n    :return: an explicit list of kpoints\n    :rtype: aiida.orm.KpointsData\n    \"\"\"\n    try:  # test if it is a mesh\n        results = kmesh.get_kpoints_mesh()",
        "detail": "aiida_mobility.calculations.functions.kmesh",
        "documentation": {}
    },
    {
        "label": "PerturboCalculation",
        "kind": 6,
        "importPath": "aiida_mobility.calculations.perturbo",
        "description": "aiida_mobility.calculations.perturbo",
        "peekOfCode": "class PerturboCalculation(BaseCalculation):\n    \"\"\"\n    qe2pert calculation.\n    \"\"\"\n    _PREFIX = \"aiida\"\n    _DEFAULT_INPUT_FILE = \"aiida.in\"\n    _DEFAULT_OUTPUT_FILE = \"aiida.out\"\n    _DEFAULT_EPWAN_FILE = \"aiida_epwan.h5\"\n    _DEFAULT_TEMPER_FILE = \"aiida.temper\"\n    _DEFAULT_RETRIEVE_TEMP_LIST = [",
        "detail": "aiida_mobility.calculations.perturbo",
        "documentation": {}
    },
    {
        "label": "PhRecoverCalculation",
        "kind": 6,
        "importPath": "aiida_mobility.calculations.ph_recover",
        "description": "aiida_mobility.calculations.ph_recover",
        "peekOfCode": "class PhRecoverCalculation(CalcJob):\n    \"\"\"`CalcJob` implementation for the ph.x code of Quantum ESPRESSO.\"\"\"\n    # Keywords that cannot be set by the user but will be set by the plugin\n    _use_kpoints = True\n    # Default input and output files\n    _PREFIX = \"aiida\"\n    _DEFAULT_INPUT_FILE = \"aiida.in\"\n    _DEFAULT_OUTPUT_FILE = \"aiida.out\"\n    _OUTPUT_XML_TENSOR_FILE_NAME = \"tensors.xml\"\n    _OUTPUT_SUBFOLDER = \"./out/\"",
        "detail": "aiida_mobility.calculations.ph_recover",
        "documentation": {}
    },
    {
        "label": "QE2PertCalculation",
        "kind": 6,
        "importPath": "aiida_mobility.calculations.qe2pert",
        "description": "aiida_mobility.calculations.qe2pert",
        "peekOfCode": "class QE2PertCalculation(BaseCalculation):\n    \"\"\"\n    qe2pert calculation.\n    \"\"\"\n    _PREFIX = \"aiida\"\n    _DEFAULT_INPUT_FILE = \"aiida.in\"\n    _DEFAULT_OUTPUT_FILE = \"aiida.out\"\n    _DEFAULT_EPWAN_FILE = \"aiida_epwan.h5\"\n    _DEFAULT_RETRIEVE_TEMP_LIST = [\n        _DEFAULT_EPWAN_FILE,",
        "detail": "aiida_mobility.calculations.qe2pert",
        "documentation": {}
    },
    {
        "label": "echo_process_results",
        "kind": 2,
        "importPath": "aiida_mobility.cli.utils.display",
        "description": "aiida_mobility.cli.utils.display",
        "peekOfCode": "def echo_process_results(node):\n    \"\"\"Display a formatted table of the outputs registered for the given process node.\n    :param node: the `ProcessNode` of a terminated process\n    \"\"\"\n    from aiida.common.links import LinkType\n    class_name = node.process_class.__name__\n    outputs = node.get_outgoing(link_type=(LinkType.CREATE, LinkType.RETURN)).all()\n    if hasattr(node, 'dry_run_info'):\n        # It is a dry-run: get the information and print it\n        rel_path = os.path.relpath(node.dry_run_info['folder'])",
        "detail": "aiida_mobility.cli.utils.display",
        "documentation": {}
    },
    {
        "label": "add_to_group",
        "kind": 2,
        "importPath": "aiida_mobility.cli.utils.launch",
        "description": "aiida_mobility.cli.utils.launch",
        "peekOfCode": "def add_to_group(node, group_name):\n    if group_name is not None:\n        try:\n            g = orm.Group.get(label=group_name)\n            group_statistics = \"that already contains {} nodes\".format(\n                len(g.nodes)\n            )\n        except NotExistent:\n            g = orm.Group(label=group_name)\n            group_statistics = \"that does not exist yet\"",
        "detail": "aiida_mobility.cli.utils.launch",
        "documentation": {}
    },
    {
        "label": "launch_process",
        "kind": 2,
        "importPath": "aiida_mobility.cli.utils.launch",
        "description": "aiida_mobility.cli.utils.launch",
        "peekOfCode": "def launch_process(process, daemon, **inputs):\n    \"\"\"Launch a process with the given inputs.\n    If not sent to the daemon, the results will be displayed after the calculation finishes.\n    :param process: the process class\n    :param daemon: boolean, if True will submit to the daemon instead of running in current interpreter\n    :param inputs: inputs for the process\n    \"\"\"\n    from aiida.engine import launch, Process, ProcessBuilder\n    if isinstance(process, ProcessBuilder):\n        process_name = process.process_class.__name__",
        "detail": "aiida_mobility.cli.utils.launch",
        "documentation": {}
    },
    {
        "label": "StructureParamType",
        "kind": 6,
        "importPath": "aiida_mobility.cli.utils.options",
        "description": "aiida_mobility.cli.utils.options",
        "peekOfCode": "class StructureParamType(click.ParamType):\n    name = \"structure\"\n    def convert(self, value, param, ctx):\n        try:\n            if isinstance(value, orm.StructureData):\n                return value\n            else:\n                return read_structure(value)\n        except Exception:\n            self.fail(",
        "detail": "aiida_mobility.cli.utils.options",
        "documentation": {}
    },
    {
        "label": "StoreKeyPairParam",
        "kind": 2,
        "importPath": "aiida_mobility.cli.utils.options",
        "description": "aiida_mobility.cli.utils.options",
        "peekOfCode": "def StoreKeyPairParam(ctx, param, value):\n    my_dict = {}\n    for arg in value:\n        k, v = arg.split(\"=\", 1)\n        if v in [\"True\", \"true\"]:\n            my_dict[k] = True\n        elif v in [\"False\", \"false\"]:\n            my_dict[k] = False\n        else:\n            try:",
        "detail": "aiida_mobility.cli.utils.options",
        "documentation": {}
    },
    {
        "label": "STRUCTURE",
        "kind": 5,
        "importPath": "aiida_mobility.cli.utils.options",
        "description": "aiida_mobility.cli.utils.options",
        "peekOfCode": "STRUCTURE = OverridableOption(\n    \"-S\",\n    \"--structure\",\n    type=StructureParamType(),\n    help=\"StructureData node or Structure file(xsf,cif,poscar).\",\n)\nKPOINTS_DISTANCE = OverridableOption(\n    \"--kpoints-distance\",\n    type=click.FLOAT,\n    default=0.5,",
        "detail": "aiida_mobility.cli.utils.options",
        "documentation": {}
    },
    {
        "label": "KPOINTS_DISTANCE",
        "kind": 5,
        "importPath": "aiida_mobility.cli.utils.options",
        "description": "aiida_mobility.cli.utils.options",
        "peekOfCode": "KPOINTS_DISTANCE = OverridableOption(\n    \"--kpoints-distance\",\n    type=click.FLOAT,\n    default=0.5,\n    show_default=True,\n    help=\"The minimal distance between k-points in reciprocal space in inverse Ångström.\",\n)\nKPOINTS_MESH = OverridableOption(\n    \"--kpoints-mesh\",\n    \"kpoints_mesh\",",
        "detail": "aiida_mobility.cli.utils.options",
        "documentation": {}
    },
    {
        "label": "KPOINTS_MESH",
        "kind": 5,
        "importPath": "aiida_mobility.cli.utils.options",
        "description": "aiida_mobility.cli.utils.options",
        "peekOfCode": "KPOINTS_MESH = OverridableOption(\n    \"--kpoints-mesh\",\n    \"kpoints_mesh\",\n    nargs=3,\n    type=click.INT,\n    default=None,\n    show_default=True,\n    callback=validate.validate_kpoints_mesh,\n    help=\"The number of points in the kpoint mesh along each basis vector.\",\n)",
        "detail": "aiida_mobility.cli.utils.options",
        "documentation": {}
    },
    {
        "label": "QPOINTS_MESH",
        "kind": 5,
        "importPath": "aiida_mobility.cli.utils.options",
        "description": "aiida_mobility.cli.utils.options",
        "peekOfCode": "QPOINTS_MESH = OverridableOption(\n    \"--qpoints-mesh\",\n    \"qpoints_mesh\",\n    nargs=3,\n    type=click.INT,\n    show_default=True,\n    callback=validate.validate_kpoints_mesh,\n    help=\"The number of points in the qpoint mesh along each basis vector.\",\n)\nQPOINTS_DISTANCE = OverridableOption(",
        "detail": "aiida_mobility.cli.utils.options",
        "documentation": {}
    },
    {
        "label": "QPOINTS_DISTANCE",
        "kind": 5,
        "importPath": "aiida_mobility.cli.utils.options",
        "description": "aiida_mobility.cli.utils.options",
        "peekOfCode": "QPOINTS_DISTANCE = OverridableOption(\n    \"--qpoints-distance\",\n    type=click.FLOAT,\n    default=0.5,\n    show_default=True,\n    help=\"The minimal distance between k-points in reciprocal space in inverse Ångström.\",\n)\nMAX_NUM_MACHINES = OverridableOption(\n    \"-m\",\n    \"--max-num-machines\",",
        "detail": "aiida_mobility.cli.utils.options",
        "documentation": {}
    },
    {
        "label": "MAX_NUM_MACHINES",
        "kind": 5,
        "importPath": "aiida_mobility.cli.utils.options",
        "description": "aiida_mobility.cli.utils.options",
        "peekOfCode": "MAX_NUM_MACHINES = OverridableOption(\n    \"-m\",\n    \"--max-num-machines\",\n    type=click.INT,\n    default=1,\n    show_default=True,\n    help=\"The maximum number of machines (nodes) to use for the calculations.\",\n)\nMAX_WALLCLOCK_SECONDS = OverridableOption(\n    \"-w\",",
        "detail": "aiida_mobility.cli.utils.options",
        "documentation": {}
    },
    {
        "label": "MAX_WALLCLOCK_SECONDS",
        "kind": 5,
        "importPath": "aiida_mobility.cli.utils.options",
        "description": "aiida_mobility.cli.utils.options",
        "peekOfCode": "MAX_WALLCLOCK_SECONDS = OverridableOption(\n    \"-w\",\n    \"--max-wallclock-seconds\",\n    type=click.INT,\n    default=1800,\n    show_default=True,\n    help=\"the maximum wallclock time in seconds to set for the calculations.\",\n)\nWITH_MPI = OverridableOption(\n    \"-i\",",
        "detail": "aiida_mobility.cli.utils.options",
        "documentation": {}
    },
    {
        "label": "WITH_MPI",
        "kind": 5,
        "importPath": "aiida_mobility.cli.utils.options",
        "description": "aiida_mobility.cli.utils.options",
        "peekOfCode": "WITH_MPI = OverridableOption(\n    \"-i\",\n    \"--with-mpi\",\n    is_flag=True,\n    default=True,\n    show_default=True,\n    help=\"Run the calculations with MPI enabled.\",\n)\nNUM_MPIPROCS_PER_MACHINE = OverridableOption(\n    \"-np\",",
        "detail": "aiida_mobility.cli.utils.options",
        "documentation": {}
    },
    {
        "label": "NUM_MPIPROCS_PER_MACHINE",
        "kind": 5,
        "importPath": "aiida_mobility.cli.utils.options",
        "description": "aiida_mobility.cli.utils.options",
        "peekOfCode": "NUM_MPIPROCS_PER_MACHINE = OverridableOption(\n    \"-np\",\n    \"--num-mpiprocs-per-machine\",\n    type=click.INT,\n    default=1,\n    show_default=True,\n    help=\"The number of process per machine (node) to use for the calculations.\",\n)\nQUEUE_NAME = OverridableOption(\n    \"--queue\",",
        "detail": "aiida_mobility.cli.utils.options",
        "documentation": {}
    },
    {
        "label": "QUEUE_NAME",
        "kind": 5,
        "importPath": "aiida_mobility.cli.utils.options",
        "description": "aiida_mobility.cli.utils.options",
        "peekOfCode": "QUEUE_NAME = OverridableOption(\n    \"--queue\",\n    default=None,\n    show_default=True,\n    help=\"The queue of PBS system.\",\n)\n# PARENT_FOLDER = OverridableOption(\n#     \"-P\",\n#     \"--parent-folder\",\n#     \"parent_folder\",",
        "detail": "aiida_mobility.cli.utils.options",
        "documentation": {}
    },
    {
        "label": "DAEMON",
        "kind": 5,
        "importPath": "aiida_mobility.cli.utils.options",
        "description": "aiida_mobility.cli.utils.options",
        "peekOfCode": "DAEMON = OverridableOption(\n    \"-d\",\n    \"--daemon\",\n    is_flag=True,\n    default=False,\n    show_default=True,\n    help=\"Submit the process to the daemon instead of running it locally.\",\n)\nCLEAN_WORKDIR = OverridableOption(\n    \"-x\",",
        "detail": "aiida_mobility.cli.utils.options",
        "documentation": {}
    },
    {
        "label": "CLEAN_WORKDIR",
        "kind": 5,
        "importPath": "aiida_mobility.cli.utils.options",
        "description": "aiida_mobility.cli.utils.options",
        "peekOfCode": "CLEAN_WORKDIR = OverridableOption(\n    \"-x\",\n    \"--clean-workdir\",\n    is_flag=True,\n    default=False,\n    show_default=True,\n    help=\"Clean the remote folder of all the launched calculations after completion of the workchain.\",\n)\nMAX_RESTART_ITERATIONS = OverridableOption(\n    \"--max-restart-iterations\",",
        "detail": "aiida_mobility.cli.utils.options",
        "documentation": {}
    },
    {
        "label": "MAX_RESTART_ITERATIONS",
        "kind": 5,
        "importPath": "aiida_mobility.cli.utils.options",
        "description": "aiida_mobility.cli.utils.options",
        "peekOfCode": "MAX_RESTART_ITERATIONS = OverridableOption(\n    \"--max-restart-iterations\",\n    type=int,\n    help=\"max restart iterations\",\n    default=1,\n)\n# AUTOMATIC_PARALLELIZATION = OverridableOption(\n#     \"-a\",\n#     \"--automatic-parallelization\",\n#     is_flag=True,",
        "detail": "aiida_mobility.cli.utils.options",
        "documentation": {}
    },
    {
        "label": "VC_RELAX",
        "kind": 5,
        "importPath": "aiida_mobility.cli.utils.options",
        "description": "aiida_mobility.cli.utils.options",
        "peekOfCode": "VC_RELAX = OverridableOption(\n    \"--vc-relax\",\n    help=\"Whether to run relax in `vc-relax` mode, or in `relax` mode.\",\n    is_flag=True,\n    default=False,\n)\nPH_EPSIL = OverridableOption(\n    \"--epsil\",\n    is_flag=True,\n    help=\"whether to set calculation mode of the first qpoint to epsil.\",",
        "detail": "aiida_mobility.cli.utils.options",
        "documentation": {}
    },
    {
        "label": "PH_EPSIL",
        "kind": 5,
        "importPath": "aiida_mobility.cli.utils.options",
        "description": "aiida_mobility.cli.utils.options",
        "peekOfCode": "PH_EPSIL = OverridableOption(\n    \"--epsil\",\n    is_flag=True,\n    help=\"whether to set calculation mode of the first qpoint to epsil.\",\n    default=False,\n)\nQ2R_ZASR = OverridableOption(  # q2r parameters\n    \"--q2r-zasr\",\n    type=click.Choice([\"crystal\", \"no\", \"simple\", \"one-dim\", \"zero-dim\"]),\n    help=\"default is `crystal`, optionals are `no`, `simple`, `one-dim`, `zero-dim`\",",
        "detail": "aiida_mobility.cli.utils.options",
        "documentation": {}
    },
    {
        "label": "Q2R_ZASR",
        "kind": 5,
        "importPath": "aiida_mobility.cli.utils.options",
        "description": "aiida_mobility.cli.utils.options",
        "peekOfCode": "Q2R_ZASR = OverridableOption(  # q2r parameters\n    \"--q2r-zasr\",\n    type=click.Choice([\"crystal\", \"no\", \"simple\", \"one-dim\", \"zero-dim\"]),\n    help=\"default is `crystal`, optionals are `no`, `simple`, `one-dim`, `zero-dim`\",\n    default=\"crystal\",\n    show_default=True,\n)\nMATDYN_ASR = OverridableOption(  # matdyn parameters\n    \"--matdyn-asr\",\n    type=click.Choice([\"crystal\", \"no\", \"simple\", \"one-dim\", \"zero-dim\"]),",
        "detail": "aiida_mobility.cli.utils.options",
        "documentation": {}
    },
    {
        "label": "MATDYN_ASR",
        "kind": 5,
        "importPath": "aiida_mobility.cli.utils.options",
        "description": "aiida_mobility.cli.utils.options",
        "peekOfCode": "MATDYN_ASR = OverridableOption(  # matdyn parameters\n    \"--matdyn-asr\",\n    type=click.Choice([\"crystal\", \"no\", \"simple\", \"one-dim\", \"zero-dim\"]),\n    help=\"default is `crystal`, optionals are `no`, `simple`, `one-dim`, `zero-dim`\",\n    default=\"crystal\",\n    show_default=True,\n)\nMATDYN_DISTANCE = OverridableOption(  # matdyn parameters\n    \"--matdyn-distance\",\n    type=click.FLOAT,",
        "detail": "aiida_mobility.cli.utils.options",
        "documentation": {}
    },
    {
        "label": "MATDYN_DISTANCE",
        "kind": 5,
        "importPath": "aiida_mobility.cli.utils.options",
        "description": "aiida_mobility.cli.utils.options",
        "peekOfCode": "MATDYN_DISTANCE = OverridableOption(  # matdyn parameters\n    \"--matdyn-distance\",\n    type=click.FLOAT,\n    default=None,\n    help=\"kpoint distance to get kpoints, default is kpoints_distance_for_bands in protocol.\",\n)\nPARAMETERS = OverridableOption(\n    \"--parameters\",\n    \"-p\",\n    multiple=True,",
        "detail": "aiida_mobility.cli.utils.options",
        "documentation": {}
    },
    {
        "label": "PARAMETERS",
        "kind": 5,
        "importPath": "aiida_mobility.cli.utils.options",
        "description": "aiida_mobility.cli.utils.options",
        "peekOfCode": "PARAMETERS = OverridableOption(\n    \"--parameters\",\n    \"-p\",\n    multiple=True,\n    callback=StoreKeyPairParam,\n    help=\"Override parameters in protocol by specifying the key and value of parameter. e.g. ecutwfc=80...\",\n    metavar=\"key1=value1...\",\n)\nPROTOCOL = OverridableOption(\n    \"--protocol\",",
        "detail": "aiida_mobility.cli.utils.options",
        "documentation": {}
    },
    {
        "label": "PROTOCOL",
        "kind": 5,
        "importPath": "aiida_mobility.cli.utils.options",
        "description": "aiida_mobility.cli.utils.options",
        "peekOfCode": "PROTOCOL = OverridableOption(\n    \"--protocol\",\n    help=\"Available protocols like 'theos-ht-1.0', 'ms-1.0', and 'testing'.\",\n    default=\"ms-1.0\",\n    show_default=True,\n)\nPARAMETERS_SET = OverridableOption(\n    \"--parameters-set\",\n    help=\"available scf parameters sets of protocols like {`fast`, `default` and `accurate`}_{``, `fixed`, `gaussian`}\",\n    default=\"default\",",
        "detail": "aiida_mobility.cli.utils.options",
        "documentation": {}
    },
    {
        "label": "PARAMETERS_SET",
        "kind": 5,
        "importPath": "aiida_mobility.cli.utils.options",
        "description": "aiida_mobility.cli.utils.options",
        "peekOfCode": "PARAMETERS_SET = OverridableOption(\n    \"--parameters-set\",\n    help=\"available scf parameters sets of protocols like {`fast`, `default` and `accurate`}_{``, `fixed`, `gaussian`}\",\n    default=\"default\",\n    show_default=True,\n)\nPSEUDO_FAMILY = OverridableOption(\"--pseudo-family\", help=\"pseudo family name\")\nCUTOFFS = OverridableOption(\n    \"--cutoffs\",\n    type=float,",
        "detail": "aiida_mobility.cli.utils.options",
        "documentation": {}
    },
    {
        "label": "PSEUDO_FAMILY",
        "kind": 5,
        "importPath": "aiida_mobility.cli.utils.options",
        "description": "aiida_mobility.cli.utils.options",
        "peekOfCode": "PSEUDO_FAMILY = OverridableOption(\"--pseudo-family\", help=\"pseudo family name\")\nCUTOFFS = OverridableOption(\n    \"--cutoffs\",\n    type=float,\n    nargs=2,\n    help=\"should be [ecutwfc] [dual]. [ecutrho] will get by dual * ecutwfc\",\n    default=None,\n)\nSYSTEM_2D = OverridableOption(\n    \"--system-2d\",",
        "detail": "aiida_mobility.cli.utils.options",
        "documentation": {}
    },
    {
        "label": "CUTOFFS",
        "kind": 5,
        "importPath": "aiida_mobility.cli.utils.options",
        "description": "aiida_mobility.cli.utils.options",
        "peekOfCode": "CUTOFFS = OverridableOption(\n    \"--cutoffs\",\n    type=float,\n    nargs=2,\n    help=\"should be [ecutwfc] [dual]. [ecutrho] will get by dual * ecutwfc\",\n    default=None,\n)\nSYSTEM_2D = OverridableOption(\n    \"--system-2d\",\n    is_flag=True,",
        "detail": "aiida_mobility.cli.utils.options",
        "documentation": {}
    },
    {
        "label": "SYSTEM_2D",
        "kind": 5,
        "importPath": "aiida_mobility.cli.utils.options",
        "description": "aiida_mobility.cli.utils.options",
        "peekOfCode": "SYSTEM_2D = OverridableOption(\n    \"--system-2d\",\n    is_flag=True,\n    help=\"Set mesh to 2D mesh according to cell lengths\",\n    default=False,\n)\nRUN_RELAX = OverridableOption(\n    \"--run-relax\",\n    is_flag=True,\n    help=\"Whether to run relax before scf.\",",
        "detail": "aiida_mobility.cli.utils.options",
        "documentation": {}
    },
    {
        "label": "RUN_RELAX",
        "kind": 5,
        "importPath": "aiida_mobility.cli.utils.options",
        "description": "aiida_mobility.cli.utils.options",
        "peekOfCode": "RUN_RELAX = OverridableOption(\n    \"--run-relax\",\n    is_flag=True,\n    help=\"Whether to run relax before scf.\",\n    default=False,\n)\nSOC = OverridableOption(\n    \"--soc\",\n    is_flag=True,\n    help=\"spin_orbit_coupling\",",
        "detail": "aiida_mobility.cli.utils.options",
        "documentation": {}
    },
    {
        "label": "SOC",
        "kind": 5,
        "importPath": "aiida_mobility.cli.utils.options",
        "description": "aiida_mobility.cli.utils.options",
        "peekOfCode": "SOC = OverridableOption(\n    \"--soc\",\n    is_flag=True,\n    help=\"spin_orbit_coupling\",\n    default=False,\n)\nUSE_PRIMITIVE_STRUCTURE = OverridableOption(\n    \"--use-primitive-structure\",\n    is_flag=True,\n    help=\"Whether to use primitive structure.\",",
        "detail": "aiida_mobility.cli.utils.options",
        "documentation": {}
    },
    {
        "label": "USE_PRIMITIVE_STRUCTURE",
        "kind": 5,
        "importPath": "aiida_mobility.cli.utils.options",
        "description": "aiida_mobility.cli.utils.options",
        "peekOfCode": "USE_PRIMITIVE_STRUCTURE = OverridableOption(\n    \"--use-primitive-structure\",\n    is_flag=True,\n    help=\"Whether to use primitive structure.\",\n    default=False,\n)\nGROUP_NAME = OverridableOption(\n    \"--group-name\",\n    type=str,\n    help=\"Add this task to Group\",",
        "detail": "aiida_mobility.cli.utils.options",
        "documentation": {}
    },
    {
        "label": "GROUP_NAME",
        "kind": 5,
        "importPath": "aiida_mobility.cli.utils.options",
        "description": "aiida_mobility.cli.utils.options",
        "peekOfCode": "GROUP_NAME = OverridableOption(\n    \"--group-name\",\n    type=str,\n    help=\"Add this task to Group\",\n    default=None,\n)\nCOMPUTER = OverridableOption(\"-c\", \"--computer\", type=str, help=\"Comptuer name\")",
        "detail": "aiida_mobility.cli.utils.options",
        "documentation": {}
    },
    {
        "label": "COMPUTER",
        "kind": 5,
        "importPath": "aiida_mobility.cli.utils.options",
        "description": "aiida_mobility.cli.utils.options",
        "peekOfCode": "COMPUTER = OverridableOption(\"-c\", \"--computer\", type=str, help=\"Comptuer name\")",
        "detail": "aiida_mobility.cli.utils.options",
        "documentation": {}
    },
    {
        "label": "validate_kpoints_mesh",
        "kind": 2,
        "importPath": "aiida_mobility.cli.utils.validate",
        "description": "aiida_mobility.cli.utils.validate",
        "peekOfCode": "def validate_kpoints_mesh(ctx, param, value):\n    \"\"\"Command line option validator for a kpoints mesh tuple.\n    The value should be a tuple of three positive integers out of which a KpointsData object will be created with a mesh\n    equal to the tuple.\n    :param ctx: internal context of the click.command\n    :param param: the click Parameter, i.e. either the Option or Argument to which the validator is hooked up\n    :param value: a tuple of three positive integers\n    :returns: a KpointsData instance\n    \"\"\"\n    # pylint: disable=unused-argument",
        "detail": "aiida_mobility.cli.utils.validate",
        "documentation": {}
    },
    {
        "label": "launch_perturbo",
        "kind": 2,
        "importPath": "aiida_mobility.cli.workflows.perturbo",
        "description": "aiida_mobility.cli.workflows.perturbo",
        "peekOfCode": "def launch_perturbo(\n    ph,\n    nscf,\n    wannier,\n    bands_energy_threshold,\n    temperature,\n    carrier_concentration,\n    phfreq_cutoff,\n    delta_smear,\n    sampling,",
        "detail": "aiida_mobility.cli.workflows.perturbo",
        "documentation": {}
    },
    {
        "label": "launch_ph_bands",
        "kind": 2,
        "importPath": "aiida_mobility.cli.workflows.ph_bands",
        "description": "aiida_mobility.cli.workflows.ph_bands",
        "peekOfCode": "def launch_ph_bands(\n    structure,\n    protocol,\n    parameters_set,\n    parameters,\n    pseudo_family,\n    kpoints_mesh,\n    cutoffs,\n    system_2d,\n    run_relax,",
        "detail": "aiida_mobility.cli.workflows.ph_bands",
        "documentation": {}
    },
    {
        "label": "str_pw",
        "kind": 5,
        "importPath": "aiida_mobility.cli.workflows.ph_bands",
        "description": "aiida_mobility.cli.workflows.ph_bands",
        "peekOfCode": "str_pw = \"pw\"\nstr_ph = \"ph\"\nstr_q2r = \"q2r\"\nstr_matdyn = \"matdyn\"\n@cmd_launch.command(\"ph_bands\")\n@options.STRUCTURE()\n@options.PROTOCOL()\n@options.PARAMETERS_SET()\n@options.PARAMETERS()\n@options.PSEUDO_FAMILY()",
        "detail": "aiida_mobility.cli.workflows.ph_bands",
        "documentation": {}
    },
    {
        "label": "str_ph",
        "kind": 5,
        "importPath": "aiida_mobility.cli.workflows.ph_bands",
        "description": "aiida_mobility.cli.workflows.ph_bands",
        "peekOfCode": "str_ph = \"ph\"\nstr_q2r = \"q2r\"\nstr_matdyn = \"matdyn\"\n@cmd_launch.command(\"ph_bands\")\n@options.STRUCTURE()\n@options.PROTOCOL()\n@options.PARAMETERS_SET()\n@options.PARAMETERS()\n@options.PSEUDO_FAMILY()\n@options.KPOINTS_MESH()",
        "detail": "aiida_mobility.cli.workflows.ph_bands",
        "documentation": {}
    },
    {
        "label": "str_q2r",
        "kind": 5,
        "importPath": "aiida_mobility.cli.workflows.ph_bands",
        "description": "aiida_mobility.cli.workflows.ph_bands",
        "peekOfCode": "str_q2r = \"q2r\"\nstr_matdyn = \"matdyn\"\n@cmd_launch.command(\"ph_bands\")\n@options.STRUCTURE()\n@options.PROTOCOL()\n@options.PARAMETERS_SET()\n@options.PARAMETERS()\n@options.PSEUDO_FAMILY()\n@options.KPOINTS_MESH()\n@options.CUTOFFS()",
        "detail": "aiida_mobility.cli.workflows.ph_bands",
        "documentation": {}
    },
    {
        "label": "str_matdyn",
        "kind": 5,
        "importPath": "aiida_mobility.cli.workflows.ph_bands",
        "description": "aiida_mobility.cli.workflows.ph_bands",
        "peekOfCode": "str_matdyn = \"matdyn\"\n@cmd_launch.command(\"ph_bands\")\n@options.STRUCTURE()\n@options.PROTOCOL()\n@options.PARAMETERS_SET()\n@options.PARAMETERS()\n@options.PSEUDO_FAMILY()\n@options.KPOINTS_MESH()\n@options.CUTOFFS()\n@options.SYSTEM_2D()",
        "detail": "aiida_mobility.cli.workflows.ph_bands",
        "documentation": {}
    },
    {
        "label": "launch_relax",
        "kind": 2,
        "importPath": "aiida_mobility.cli.workflows.relax",
        "description": "aiida_mobility.cli.workflows.relax",
        "peekOfCode": "def launch_relax(\n    structure,\n    protocol,\n    parameters_set,\n    parameters,\n    pseudo_family,\n    kpoints_mesh,\n    cutoffs,\n    system_2d,\n    vc_relax,",
        "detail": "aiida_mobility.cli.workflows.relax",
        "documentation": {}
    },
    {
        "label": "code_str",
        "kind": 5,
        "importPath": "aiida_mobility.cli.workflows.relax",
        "description": "aiida_mobility.cli.workflows.relax",
        "peekOfCode": "code_str = \"pw\"\n@cmd_launch.command(\"relax\")\n@options.STRUCTURE()\n@options.PROTOCOL()\n@options.PARAMETERS_SET()\n@options.PARAMETERS()\n@options.PSEUDO_FAMILY()\n@options.KPOINTS_MESH()\n@options.CUTOFFS()\n@options.SYSTEM_2D()",
        "detail": "aiida_mobility.cli.workflows.relax",
        "documentation": {}
    },
    {
        "label": "launch_automated_wannier",
        "kind": 2,
        "importPath": "aiida_mobility.cli.workflows.wannier",
        "description": "aiida_mobility.cli.workflows.wannier",
        "peekOfCode": "def launch_automated_wannier(\n    structure,\n    protocol,\n    parameters_set,\n    parameters,\n    pseudo_family,\n    only_valence,\n    retrieve_hamiltonian,\n    plot_wannier_functions,\n    do_disentanglement,",
        "detail": "aiida_mobility.cli.workflows.wannier",
        "documentation": {}
    },
    {
        "label": "str_pw",
        "kind": 5,
        "importPath": "aiida_mobility.cli.workflows.wannier",
        "description": "aiida_mobility.cli.workflows.wannier",
        "peekOfCode": "str_pw = \"pw\"\nstr_pw2wan = \"pw2wannier90\"\nstr_projwfc = \"projwfc\"\nstr_wan = \"wannier\"\nstr_opengrid = \"opengrid\"\n@cmd_launch.command(\"automated_wannier\")\n@options.STRUCTURE()\n@options.PROTOCOL()\n@options.PARAMETERS_SET()\n@options.PARAMETERS()",
        "detail": "aiida_mobility.cli.workflows.wannier",
        "documentation": {}
    },
    {
        "label": "str_pw2wan",
        "kind": 5,
        "importPath": "aiida_mobility.cli.workflows.wannier",
        "description": "aiida_mobility.cli.workflows.wannier",
        "peekOfCode": "str_pw2wan = \"pw2wannier90\"\nstr_projwfc = \"projwfc\"\nstr_wan = \"wannier\"\nstr_opengrid = \"opengrid\"\n@cmd_launch.command(\"automated_wannier\")\n@options.STRUCTURE()\n@options.PROTOCOL()\n@options.PARAMETERS_SET()\n@options.PARAMETERS()\n@options.PSEUDO_FAMILY()",
        "detail": "aiida_mobility.cli.workflows.wannier",
        "documentation": {}
    },
    {
        "label": "str_projwfc",
        "kind": 5,
        "importPath": "aiida_mobility.cli.workflows.wannier",
        "description": "aiida_mobility.cli.workflows.wannier",
        "peekOfCode": "str_projwfc = \"projwfc\"\nstr_wan = \"wannier\"\nstr_opengrid = \"opengrid\"\n@cmd_launch.command(\"automated_wannier\")\n@options.STRUCTURE()\n@options.PROTOCOL()\n@options.PARAMETERS_SET()\n@options.PARAMETERS()\n@options.PSEUDO_FAMILY()\n@click.option(",
        "detail": "aiida_mobility.cli.workflows.wannier",
        "documentation": {}
    },
    {
        "label": "str_wan",
        "kind": 5,
        "importPath": "aiida_mobility.cli.workflows.wannier",
        "description": "aiida_mobility.cli.workflows.wannier",
        "peekOfCode": "str_wan = \"wannier\"\nstr_opengrid = \"opengrid\"\n@cmd_launch.command(\"automated_wannier\")\n@options.STRUCTURE()\n@options.PROTOCOL()\n@options.PARAMETERS_SET()\n@options.PARAMETERS()\n@options.PSEUDO_FAMILY()\n@click.option(\n    \"--only-valence\",",
        "detail": "aiida_mobility.cli.workflows.wannier",
        "documentation": {}
    },
    {
        "label": "str_opengrid",
        "kind": 5,
        "importPath": "aiida_mobility.cli.workflows.wannier",
        "description": "aiida_mobility.cli.workflows.wannier",
        "peekOfCode": "str_opengrid = \"opengrid\"\n@cmd_launch.command(\"automated_wannier\")\n@options.STRUCTURE()\n@options.PROTOCOL()\n@options.PARAMETERS_SET()\n@options.PARAMETERS()\n@options.PSEUDO_FAMILY()\n@click.option(\n    \"--only-valence\",\n    help=\"Compute only for valence bands (you must be careful to apply this only for insulators!)\",",
        "detail": "aiida_mobility.cli.workflows.wannier",
        "documentation": {}
    },
    {
        "label": "cmd_protocols",
        "kind": 2,
        "importPath": "aiida_mobility.cli.protocols",
        "description": "aiida_mobility.cli.protocols",
        "peekOfCode": "def cmd_protocols():\n    \"\"\"Commands to show protocols.\"\"\"\n@cmd_protocols.command(\"list\")\n@click.option(\n    \"-t\",\n    \"--protocol_type\",\n    help=\"protocol for pw or others.\",\n    default=\"pw\",\n    type=click.Choice([\"pw\", \"ph\"], case_sensitive=False),\n    show_choices=True,",
        "detail": "aiida_mobility.cli.protocols",
        "documentation": {}
    },
    {
        "label": "list_protocols",
        "kind": 2,
        "importPath": "aiida_mobility.cli.protocols",
        "description": "aiida_mobility.cli.protocols",
        "peekOfCode": "def list_protocols(protocol_type, protocol):\n    ipt = importlib.import_module(\n        \"aiida_mobility.utils.protocols.{}\".format(protocol_type)\n    )\n    protocols = ipt._get_all_protocol_modifiers()\n    if protocol is None:\n        sys.stdout.write(\"* \" + \"\\n* \".join(list(protocols.keys())))\n    else:\n        sys.stdout.write(\n            \"* \" + \"\\n* \".join(list(protocols[protocol][\"parameters\"].keys()))",
        "detail": "aiida_mobility.cli.protocols",
        "documentation": {}
    },
    {
        "label": "show_protocol",
        "kind": 2,
        "importPath": "aiida_mobility.cli.protocols",
        "description": "aiida_mobility.cli.protocols",
        "peekOfCode": "def show_protocol(protocol_type, protocol, parameters_set, structure):\n    s = \"* Protocol {} parameters {} detail :\\n\".format(\n        protocol, parameters_set\n    )\n    if protocol_type == \"pw\":\n        protocol, recommended_cutoffs = get_protocol(\n            structure=structure,\n            scf_parameters_name=parameters_set,\n            protocol=protocol,\n            pseudos=None,",
        "detail": "aiida_mobility.cli.protocols",
        "documentation": {}
    },
    {
        "label": "PerturboParser",
        "kind": 6,
        "importPath": "aiida_mobility.parsers.data_parser.perturbo_parser",
        "description": "aiida_mobility.parsers.data_parser.perturbo_parser",
        "peekOfCode": "class PerturboParser(object):\n    \"\"\"PerturboParser Generates a PerturboParser instance .\n    Args:\n        object ([type]): [description]\n    Raises:\n        exceptions.InputValidationError: [description]\n        exceptions.InputValidationError: [description]\n    TODO: verify parameters of diffrent calc modes.\n    \"\"\"\n    _blocked_keys = [",
        "detail": "aiida_mobility.parsers.data_parser.perturbo_parser",
        "documentation": {}
    },
    {
        "label": "QE2pertParser",
        "kind": 6,
        "importPath": "aiida_mobility.parsers.data_parser.qe2pert_parser",
        "description": "aiida_mobility.parsers.data_parser.qe2pert_parser",
        "peekOfCode": "class QE2pertParser(object):\n    _key = [\n        \"prefix\",\n        \"outdir\",\n        \"phdir\",\n        \"nk1\",\n        \"nk2\",\n        \"nk3\",\n        \"dft_band_min\",\n        \"dft_band_max\",",
        "detail": "aiida_mobility.parsers.data_parser.qe2pert_parser",
        "documentation": {}
    },
    {
        "label": "QE2PertParser",
        "kind": 6,
        "importPath": "aiida_mobility.parsers.qe2pert",
        "description": "aiida_mobility.parsers.qe2pert",
        "peekOfCode": "class QE2PertParser(Parser):\n    \"\"\"Parser for an `QE2PertCalculation` job.\"\"\"\n    def parse(self, **kwargs):\n        \"\"\"Parse the contents of the output files stored in the `retrieved` output node.\"\"\"\n        try:\n            retrieved = self.retrieved\n        except NotExistent:\n            self.logger.error(\"No retrieved folder found\")\n            return self.exit_codes.ERROR_NO_RETRIEVED_FOLDER\n        # The stdout is required for parsing",
        "detail": "aiida_mobility.parsers.qe2pert",
        "documentation": {}
    },
    {
        "label": "distEclud",
        "kind": 2,
        "importPath": "aiida_mobility.tools.compare_dft_wannier_bands",
        "description": "aiida_mobility.tools.compare_dft_wannier_bands",
        "peekOfCode": "def distEclud(x, y):\n    return np.sqrt(np.sum((x - y) ** 2))\n# TODO: compare_bands_data\ndef compare_bands_data(\n    dft_bands, wan_bands, emin=None, emax=None, fermi_energy=None\n):\n    if dft_bands.shape[0] == wan_bands.shape[0]:\n        inner_dft_bands = range(0, dft_bands.shape[1])\n        inner_wan_bands = range(0, wan_bands.shape[1])\n        if all(e is not None for e in (emin, emax)):",
        "detail": "aiida_mobility.tools.compare_dft_wannier_bands",
        "documentation": {}
    },
    {
        "label": "compare_bands_data",
        "kind": 2,
        "importPath": "aiida_mobility.tools.compare_dft_wannier_bands",
        "description": "aiida_mobility.tools.compare_dft_wannier_bands",
        "peekOfCode": "def compare_bands_data(\n    dft_bands, wan_bands, emin=None, emax=None, fermi_energy=None\n):\n    if dft_bands.shape[0] == wan_bands.shape[0]:\n        inner_dft_bands = range(0, dft_bands.shape[1])\n        inner_wan_bands = range(0, wan_bands.shape[1])\n        if all(e is not None for e in (emin, emax)):\n            index = 0\n            inner_dft_bands = []\n            inner_wan_bands = []",
        "detail": "aiida_mobility.tools.compare_dft_wannier_bands",
        "documentation": {}
    },
    {
        "label": "required_length",
        "kind": 2,
        "importPath": "aiida_mobility.tools.compare_dft_wannier_bands",
        "description": "aiida_mobility.tools.compare_dft_wannier_bands",
        "peekOfCode": "def required_length(nmin, nmax):\n    class RequiredLength(argparse.Action):\n        def __call__(self, parser, args, values, option_string=None):\n            if not nmin <= len(values) <= nmax:\n                msg = 'argument \"{f}\" requires between {nmin} and {nmax} arguments'.format(\n                    f=self.dest, nmin=nmin, nmax=nmax\n                )\n                raise argparse.ArgumentTypeError(msg)\n            setattr(args, self.dest, values)\n    return RequiredLength",
        "detail": "aiida_mobility.tools.compare_dft_wannier_bands",
        "documentation": {}
    },
    {
        "label": "get_pythtb",
        "kind": 2,
        "importPath": "aiida_mobility.tools.get_w90model_from_aiida",
        "description": "aiida_mobility.tools.get_w90model_from_aiida",
        "peekOfCode": "def get_pythtb(wan_calculation, xyz_workaround=False):\n    tmpdir = tempfile.mkdtemp()\n    seedname = os.path.splitext(wan_calculation._INPUT_FILE)[0]\n    out_dir = os.path.join(\n        wan_calculation.out.retrieved.folder.abspath, \"path\"\n    )\n    for filepath in [\n        os.path.join(\n            wan_calculation.folder.abspath, \"raw_input\",\n            \"{}.win\".format(seedname)",
        "detail": "aiida_mobility.tools.get_w90model_from_aiida",
        "documentation": {}
    },
    {
        "label": "isNode",
        "kind": 2,
        "importPath": "aiida_mobility.tools.plot_projectabilities",
        "description": "aiida_mobility.tools.plot_projectabilities",
        "peekOfCode": "def isNode(NodeType):\n    return lambda x: x.process_label == NodeType\ndef findNodes(NodeType, NodeList):\n    # return sorted\n    nodes = list(filter(isNode(NodeType), NodeList))\n    nodes.sort(key=lambda x: x.pk)\n    return nodes\ndef findLastNode(NodeType, NodeList):\n    # return last one\n    return findNodes(NodeType, NodeList)[-1]",
        "detail": "aiida_mobility.tools.plot_projectabilities",
        "documentation": {}
    },
    {
        "label": "findNodes",
        "kind": 2,
        "importPath": "aiida_mobility.tools.plot_projectabilities",
        "description": "aiida_mobility.tools.plot_projectabilities",
        "peekOfCode": "def findNodes(NodeType, NodeList):\n    # return sorted\n    nodes = list(filter(isNode(NodeType), NodeList))\n    nodes.sort(key=lambda x: x.pk)\n    return nodes\ndef findLastNode(NodeType, NodeList):\n    # return last one\n    return findNodes(NodeType, NodeList)[-1]\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(",
        "detail": "aiida_mobility.tools.plot_projectabilities",
        "documentation": {}
    },
    {
        "label": "findLastNode",
        "kind": 2,
        "importPath": "aiida_mobility.tools.plot_projectabilities",
        "description": "aiida_mobility.tools.plot_projectabilities",
        "peekOfCode": "def findLastNode(NodeType, NodeList):\n    # return last one\n    return findNodes(NodeType, NodeList)[-1]\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(\n        description=\"A script to plot the projectabilities distribution\"\n    )\n    parser.add_argument(\n        \"pk\",\n        metavar=\"WORKCHAIN_PK\",",
        "detail": "aiida_mobility.tools.plot_projectabilities",
        "documentation": {}
    },
    {
        "label": "get_ph_protocol_parameters",
        "kind": 2,
        "importPath": "aiida_mobility.utils.protocols.ph",
        "description": "aiida_mobility.utils.protocols.ph",
        "peekOfCode": "def get_ph_protocol_parameters(name=\"ms-1.0\", set=None):\n    return _protocol[name][\"parameters\"][\n        _protocol[name][\"parameters_default\"] if set is None else set\n    ]\ndef _get_all_protocol_modifiers():\n    return _protocol",
        "detail": "aiida_mobility.utils.protocols.ph",
        "documentation": {}
    },
    {
        "label": "_protocol",
        "kind": 5,
        "importPath": "aiida_mobility.utils.protocols.ph",
        "description": "aiida_mobility.utils.protocols.ph",
        "peekOfCode": "_protocol = {\n    \"ms-1.0\": {\n        \"parameters\": {\n            \"test\": {\n                \"tr2_ph\": 1e-6,\n                \"qpoints_distance\": 0.6,\n                \"max_wallclock_seconds\": 3600 * 60,\n                \"check_imaginary_frequencies\": False,\n                \"epsil\": False,\n                \"separated_qpoints\": False,",
        "detail": "aiida_mobility.utils.protocols.ph",
        "documentation": {}
    },
    {
        "label": "ProtocolManager",
        "kind": 6,
        "importPath": "aiida_mobility.utils.protocols.pw",
        "description": "aiida_mobility.utils.protocols.pw",
        "peekOfCode": "class ProtocolManager:\n    \"\"\"A class to manage calculation protocols.\"\"\"\n    def __init__(self, name):\n        \"\"\"Initialize a protocol instance.\n        Pass a string specifying the protocol.\n        \"\"\"\n        self.name = name\n        try:\n            self.modifiers = _get_all_protocol_modifiers()[name]\n        except KeyError as exception:",
        "detail": "aiida_mobility.utils.protocols.pw",
        "documentation": {}
    },
    {
        "label": "erfc_scdm",
        "kind": 2,
        "importPath": "aiida_mobility.utils.scdm",
        "description": "aiida_mobility.utils.scdm",
        "peekOfCode": "def erfc_scdm(x, mu, sigma):\n    return 0.5 * erfc((x - mu) / sigma)\ndef fit_erfc(f, xdata, ydata):\n    return curve_fit(f, xdata, ydata, bounds=([-50, 0], [50, 50]))\ndef fit_scdm_mu_sigma(bands: np.array, projections: np.array, thresholds: dict = {'sigma_factor', 3}, return_data: bool = False) -> typing.Union[typing.Tuple[float, float], typing.Tuple[float, float, np.array]]:\n    '''Fit mu parameter for the SCDM-k method:\n    The projectability of all orbitals is fitted using an erfc(x) function. \n    Mu and sigma are extracted from the fitted distribution,\n    with mu = mu_fit - k * sigma, sigma = sigma_fit and\n    k a parameter with default k = 3.",
        "detail": "aiida_mobility.utils.scdm",
        "documentation": {}
    },
    {
        "label": "fit_erfc",
        "kind": 2,
        "importPath": "aiida_mobility.utils.scdm",
        "description": "aiida_mobility.utils.scdm",
        "peekOfCode": "def fit_erfc(f, xdata, ydata):\n    return curve_fit(f, xdata, ydata, bounds=([-50, 0], [50, 50]))\ndef fit_scdm_mu_sigma(bands: np.array, projections: np.array, thresholds: dict = {'sigma_factor', 3}, return_data: bool = False) -> typing.Union[typing.Tuple[float, float], typing.Tuple[float, float, np.array]]:\n    '''Fit mu parameter for the SCDM-k method:\n    The projectability of all orbitals is fitted using an erfc(x) function. \n    Mu and sigma are extracted from the fitted distribution,\n    with mu = mu_fit - k * sigma, sigma = sigma_fit and\n    k a parameter with default k = 3.\n    This function accepts numpy array inputs, the function `fit_scdm_mu_sigma_aiida` \n    is the AiiDA wrapper which accepts AiiDA type as input parameters.",
        "detail": "aiida_mobility.utils.scdm",
        "documentation": {}
    },
    {
        "label": "fit_scdm_mu_sigma",
        "kind": 2,
        "importPath": "aiida_mobility.utils.scdm",
        "description": "aiida_mobility.utils.scdm",
        "peekOfCode": "def fit_scdm_mu_sigma(bands: np.array, projections: np.array, thresholds: dict = {'sigma_factor', 3}, return_data: bool = False) -> typing.Union[typing.Tuple[float, float], typing.Tuple[float, float, np.array]]:\n    '''Fit mu parameter for the SCDM-k method:\n    The projectability of all orbitals is fitted using an erfc(x) function. \n    Mu and sigma are extracted from the fitted distribution,\n    with mu = mu_fit - k * sigma, sigma = sigma_fit and\n    k a parameter with default k = 3.\n    This function accepts numpy array inputs, the function `fit_scdm_mu_sigma_aiida` \n    is the AiiDA wrapper which accepts AiiDA type as input parameters.\n    :param bands: output of projwfc, it was computed in the nscf calc\n    :param projections: output of projwfc",
        "detail": "aiida_mobility.utils.scdm",
        "documentation": {}
    },
    {
        "label": "fit_scdm_mu_sigma_aiida",
        "kind": 2,
        "importPath": "aiida_mobility.utils.scdm",
        "description": "aiida_mobility.utils.scdm",
        "peekOfCode": "def fit_scdm_mu_sigma_aiida(bands: orm.BandsData, projections: orm.ProjectionData, thresholds: dict, return_data: bool = False) -> typing.Union[typing.Tuple[float, float], typing.Tuple[float, float, np.array]]:\n    \"\"\"Fit scdm_mu & scdm_sigma based on projectability.\n    This is the AiiDA wrapper of `fit_scdm_mu_sigma`.\n    :param pw2wan_parameters: pw2wannier90 input parameters (the one to update with this calcfunction)\n    :type pw2wan_parameters: orm.Dict\n    :param bands: band structure of the projwfc output\n    :type bands: orm.BandsData\n    :param projections: projectability of the projwfc output\n    :type projections: orm.ProjectionData\n    :param thresholds: thresholds of SCDM",
        "detail": "aiida_mobility.utils.scdm",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "aiida_mobility.utils.scdm",
        "description": "aiida_mobility.utils.scdm",
        "peekOfCode": "__all__ = ('erfc_scdm', 'fit_scdm_mu_sigma', 'fit_scdm_mu_sigma_aiida')\ndef erfc_scdm(x, mu, sigma):\n    return 0.5 * erfc((x - mu) / sigma)\ndef fit_erfc(f, xdata, ydata):\n    return curve_fit(f, xdata, ydata, bounds=([-50, 0], [50, 50]))\ndef fit_scdm_mu_sigma(bands: np.array, projections: np.array, thresholds: dict = {'sigma_factor', 3}, return_data: bool = False) -> typing.Union[typing.Tuple[float, float], typing.Tuple[float, float, np.array]]:\n    '''Fit mu parameter for the SCDM-k method:\n    The projectability of all orbitals is fitted using an erfc(x) function. \n    Mu and sigma are extracted from the fitted distribution,\n    with mu = mu_fit - k * sigma, sigma = sigma_fit and",
        "detail": "aiida_mobility.utils.scdm",
        "documentation": {}
    },
    {
        "label": "get_ppheader",
        "kind": 2,
        "importPath": "aiida_mobility.utils.upf",
        "description": "aiida_mobility.utils.upf",
        "peekOfCode": "def get_ppheader(upf_content: str) -> str:\n    upf_content = upf_content.split('\\n')\n    # get PP_HEADER block\n    ppheader_block = ''\n    found_begin = False\n    found_end = False\n    for line in upf_content:\n        if '<PP_HEADER' in line:\n            ppheader_block += line + '\\n'\n            if not found_begin:",
        "detail": "aiida_mobility.utils.upf",
        "documentation": {}
    },
    {
        "label": "is_soc_pseudo",
        "kind": 2,
        "importPath": "aiida_mobility.utils.upf",
        "description": "aiida_mobility.utils.upf",
        "peekOfCode": "def is_soc_pseudo(upf_content: str) -> bool:\n    \"\"\"check if it is a SOC pseudo\n    :param upf_content: the content of the UPF file\n    :type upf_content: str\n    :return: [description]\n    :rtype: bool\n    \"\"\"\n    ppheader_block = get_ppheader(upf_content)\n    # parse XML\n    PP_HEADER = ET.XML(ppheader_block)",
        "detail": "aiida_mobility.utils.upf",
        "documentation": {}
    },
    {
        "label": "parse_zvalence",
        "kind": 2,
        "importPath": "aiida_mobility.utils.upf",
        "description": "aiida_mobility.utils.upf",
        "peekOfCode": "def parse_zvalence(upf_content: str) -> float:\n    \"\"\"get z_valcence from a UPF file. No AiiDA dependencies.\n    Works for both UPF v1 & v2 format, non-relativistic & relativistic.\n    Tested on all the SSSP pseudos.\n    :param upf_content: the content of the UPF file\n    :type upf_content: str\n    :return: z_valence of the UPF file\n    :rtype: float\n    \"\"\"\n    ppheader_block = get_ppheader(upf_content)",
        "detail": "aiida_mobility.utils.upf",
        "documentation": {}
    },
    {
        "label": "get_upf_content",
        "kind": 2,
        "importPath": "aiida_mobility.utils.upf",
        "description": "aiida_mobility.utils.upf",
        "peekOfCode": "def get_upf_content(upf: orm.UpfData) -> str:\n    \"\"\"Retreive the content of the UpfData\n    :param upf: [description]\n    :type upf: orm.UpfData\n    :return: [description]\n    :rtype: str\n    \"\"\"\n    if not isinstance(upf, orm.UpfData):\n        raise ValueError(f'The type of upf is {type(upf)}, only aiida.orm.UpfData is accepted')\n    upf_name = upf.list_object_names()[0]",
        "detail": "aiida_mobility.utils.upf",
        "documentation": {}
    },
    {
        "label": "get_number_of_electrons_from_upf",
        "kind": 2,
        "importPath": "aiida_mobility.utils.upf",
        "description": "aiida_mobility.utils.upf",
        "peekOfCode": "def get_number_of_electrons_from_upf(upf: orm.UpfData) -> float:\n    \"\"\"AiiDA wrapper for `parse_zvalence'\n    :param upf: pseudo\n    :type upf: aiida.orm.UpfData\n    :return: number of electrons\n    :rtype: float\n    \"\"\"\n    upf_content = get_upf_content(upf)\n    return parse_zvalence(upf_content)\ndef get_number_of_electrons(structure: orm.StructureData, pseudos: Dict_of_Upf) -> float:",
        "detail": "aiida_mobility.utils.upf",
        "documentation": {}
    },
    {
        "label": "get_number_of_electrons",
        "kind": 2,
        "importPath": "aiida_mobility.utils.upf",
        "description": "aiida_mobility.utils.upf",
        "peekOfCode": "def get_number_of_electrons(structure: orm.StructureData, pseudos: Dict_of_Upf) -> float:\n    \"\"\"get number of electrons for the structure based on pseudopotentials\n    Usage:\n        nprojs = get_number_of_electrons(struct_MgO, {'Mg':UpfData_Mg, 'O':UpfData_O})\n    :param structure: crystal structure\n    :type structure: aiida.orm.StructureData\n    :param pseudos: a dictionary contains orm.UpfData of the structure\n    :type pseudos: dict\n    :return: number of electrons\n    :rtype: float",
        "detail": "aiida_mobility.utils.upf",
        "documentation": {}
    },
    {
        "label": "parse_pswfc_soc",
        "kind": 2,
        "importPath": "aiida_mobility.utils.upf",
        "description": "aiida_mobility.utils.upf",
        "peekOfCode": "def parse_pswfc_soc(upf_content: str) -> list:\n    \"\"\"parse the PP_SPIN_ORB block in SOC UPF.\n    This is also the orbitals used for projections in projwfc.x.\n    No AiiDA dependencies.\n    Works for both UPF v1 & v2 format.\n    :param upf_content: [description]\n    :type upf_content: str\n    :raises ValueError: [description]\n    :return: list of dict, each dict contains 3 keys for quantum number n, l, j\n    :rtype: list",
        "detail": "aiida_mobility.utils.upf",
        "documentation": {}
    },
    {
        "label": "parse_pswfc_nosoc",
        "kind": 2,
        "importPath": "aiida_mobility.utils.upf",
        "description": "aiida_mobility.utils.upf",
        "peekOfCode": "def parse_pswfc_nosoc(upf_content: str) -> list:\n    \"\"\"for non-relativistic pseudo\n    :param upf_content: [description]\n    :type upf_content: str\n    :return: list of dict, each dict contains 1 key for quantum number l\n    :rtype: list\n    \"\"\"\n    if is_soc_pseudo(upf_content):\n        raise ValueError('Only accept non-SOC pseudo')\n    upf_content = upf_content.split('\\n')",
        "detail": "aiida_mobility.utils.upf",
        "documentation": {}
    },
    {
        "label": "get_projections_from_upf",
        "kind": 2,
        "importPath": "aiida_mobility.utils.upf",
        "description": "aiida_mobility.utils.upf",
        "peekOfCode": "def get_projections_from_upf(upf: orm.UpfData):\n    \"\"\"Return a list of strings for Wannier90 projection block\n    :param upf: the pseduo to be parsed\n    :type upf: orm.UpfData\n    :return: list of projections\n    :rtype: list\n    \"\"\"\n    class Orbit:\n        \"\"\"A simple class to help sorting/removing the orbitals in a list\n        \"\"\"",
        "detail": "aiida_mobility.utils.upf",
        "documentation": {}
    },
    {
        "label": "get_projections",
        "kind": 2,
        "importPath": "aiida_mobility.utils.upf",
        "description": "aiida_mobility.utils.upf",
        "peekOfCode": "def get_projections(structure: orm.StructureData, pseudos: Dict_of_Upf):\n    \"\"\"get wannier90 projection block for the crystal structure \n    based on pseudopotential files.\n    Usage:\n        projs = get_projections(struct_MgO, {'Mg':UpfData_Mg, 'O':UpfData_O})\n    :param structure: crystal structure\n    :type structure: aiida.orm.StructureData\n    :param pseudos: a dictionary contains orm.UpfData of the structure\n    :type pseudos: dict\n    :return: wannier90 projection block",
        "detail": "aiida_mobility.utils.upf",
        "documentation": {}
    },
    {
        "label": "parse_number_of_pswfc",
        "kind": 2,
        "importPath": "aiida_mobility.utils.upf",
        "description": "aiida_mobility.utils.upf",
        "peekOfCode": "def parse_number_of_pswfc(upf_content: str) -> int:\n    \"\"\"Get the number of orbitals in the UPF file.\n    This is also the number of orbitals used for projections in projwfc.x.\n    No AiiDA dependencies.\n    Works for both UPF v1 & v2 format, non-relativistic & relativistic.\n    Tested on all the SSSP pseudos.\n    :param upf_content: the content of the UPF file\n    :type upf_content: str\n    :return: number of PSWFC \n    :rtype: int",
        "detail": "aiida_mobility.utils.upf",
        "documentation": {}
    },
    {
        "label": "get_number_of_projections_from_upf",
        "kind": 2,
        "importPath": "aiida_mobility.utils.upf",
        "description": "aiida_mobility.utils.upf",
        "peekOfCode": "def get_number_of_projections_from_upf(upf: orm.UpfData) -> int:\n    \"\"\"aiida wrapper for `parse_number_of_pswfc`.\n    :param upf: the UPF file\n    :type upf: aiida.orm.UpfData\n    :return: number of projections in the UPF file\n    :rtype: int\n    \"\"\"\n    upf_content = get_upf_content(upf)\n    return parse_number_of_pswfc(upf_content)\ndef get_number_of_projections(structure: orm.StructureData, pseudos: Dict_of_Upf) -> int:",
        "detail": "aiida_mobility.utils.upf",
        "documentation": {}
    },
    {
        "label": "get_number_of_projections",
        "kind": 2,
        "importPath": "aiida_mobility.utils.upf",
        "description": "aiida_mobility.utils.upf",
        "peekOfCode": "def get_number_of_projections(structure: orm.StructureData, pseudos: Dict_of_Upf) -> int:\n    \"\"\"get number of projections for the crystal structure \n    based on pseudopotential files.\n    Usage:\n        nprojs = get_number_of_projections(struct_MgO, {'Mg':UpfData_Mg, 'O':UpfData_O})\n    :param structure: crystal structure\n    :type structure: aiida.orm.StructureData\n    :param pseudos: a dictionary contains orm.UpfData of the structure\n    :type pseudos: dict\n    :return: number of projections",
        "detail": "aiida_mobility.utils.upf",
        "documentation": {}
    },
    {
        "label": "get_wannier_number_of_bands",
        "kind": 2,
        "importPath": "aiida_mobility.utils.upf",
        "description": "aiida_mobility.utils.upf",
        "peekOfCode": "def get_wannier_number_of_bands(structure, pseudos, only_valence=False, spin_polarized=False):\n    \"\"\"estimate number of bands for a Wannier90 calculation.\n    :param structure: crystal structure\n    :type structure: aiida.orm.StructureData\n    :param pseudos: dictionary of pseudopotentials\n    :type pseudos: dict of aiida.orm.UpfData\n    :param only_valence: return only occupied number of badns\n    :type only_valence: bool\n    :param spin_polarized: magnetic calculation?\n    :type spin_polarized: bool",
        "detail": "aiida_mobility.utils.upf",
        "documentation": {}
    },
    {
        "label": "md5",
        "kind": 2,
        "importPath": "aiida_mobility.utils.upf",
        "description": "aiida_mobility.utils.upf",
        "peekOfCode": "def md5(filename):\n    hash_md5 = hashlib.md5()\n    with open(filename, \"rb\") as f:\n        for chunk in iter(lambda: f.read(4096), b\"\"):\n            hash_md5.update(chunk)\n    return hash_md5.hexdigest()\ndef get_metadata(filename):\n    result = {\n        \"filename\": filename,\n        \"md5\": md5(filename),",
        "detail": "aiida_mobility.utils.upf",
        "documentation": {}
    },
    {
        "label": "get_metadata",
        "kind": 2,
        "importPath": "aiida_mobility.utils.upf",
        "description": "aiida_mobility.utils.upf",
        "peekOfCode": "def get_metadata(filename):\n    result = {\n        \"filename\": filename,\n        \"md5\": md5(filename),\n        \"pseudopotential\": \"100PAW\"\n        }\n    with open(filename) as f:\n        for line in f:\n            if \"Suggested minimum cutoff for wavefunctions\" in line:\n                wave = float(line.strip().split()[-2])",
        "detail": "aiida_mobility.utils.upf",
        "documentation": {}
    },
    {
        "label": "generate_pslibrary_metadata",
        "kind": 2,
        "importPath": "aiida_mobility.utils.upf",
        "description": "aiida_mobility.utils.upf",
        "peekOfCode": "def generate_pslibrary_metadata(dirname=None):\n    \"\"\"Scan the folder and generate a json file containing metainfo of pseudos of pslibrary.\n    :param dirname: folder to be scanned, if None download from QE website\n    :type dirname: str\n    \"\"\"\n    import urllib.request\n    output_filename = 'pslibrary_paw_relpbe_1.0.0.json'\n    qe_site = 'https://www.quantum-espresso.org/upf_files/'\n    # these are the suggested PP from https://dalcorso.github.io/pslibrary/PP_list.html (2020.07.21)\n    suggested = r\"\"\"H:  H.$fct-*_psl.1.0.0 ",
        "detail": "aiida_mobility.utils.upf",
        "documentation": {}
    },
    {
        "label": "generate_dojo_metadata",
        "kind": 2,
        "importPath": "aiida_mobility.utils.upf",
        "description": "aiida_mobility.utils.upf",
        "peekOfCode": "def generate_dojo_metadata():\n    \"\"\"generate metadata for pseduo-dojo SOC pseudos, from\n    http://www.pseudo-dojo.org/nc-fr-04_pbe_stringent.json\n    \"\"\"\n    dojo_json = 'nc-fr-04_pbe_standard.json'\n    with open(dojo_json) as f:\n        dojo = json.load(f)\n    result = {}\n    for element in dojo:\n        # in pseudo-dojo standard accurary, there is no UPF endswith '_r',",
        "detail": "aiida_mobility.utils.upf",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "aiida_mobility.utils.upf",
        "description": "aiida_mobility.utils.upf",
        "peekOfCode": "__all__ = (# for the content of UPF, i.e. these functions accept str as parameter\n           'parse_zvalence',\n           'parse_pswfc_nosoc', 'parse_pswfc_soc',\n           'parse_number_of_pswfc',\n           # for orm.UpfData, i.e. these functions accept orm.UpfData as parameter\n           'get_number_of_electrons_from_upf',\n           'get_projections_from_upf',\n           'get_number_of_projections_from_upf', \n           # for orm.StructreData, i.e. these functions accept orm.StructreData as parameter\n           'get_number_of_electrons',",
        "detail": "aiida_mobility.utils.upf",
        "documentation": {}
    },
    {
        "label": "Dict_of_Upf",
        "kind": 5,
        "importPath": "aiida_mobility.utils.upf",
        "description": "aiida_mobility.utils.upf",
        "peekOfCode": "Dict_of_Upf = typing.Dict[str, orm.UpfData]\ndef get_ppheader(upf_content: str) -> str:\n    upf_content = upf_content.split('\\n')\n    # get PP_HEADER block\n    ppheader_block = ''\n    found_begin = False\n    found_end = False\n    for line in upf_content:\n        if '<PP_HEADER' in line:\n            ppheader_block += line + '\\n'",
        "detail": "aiida_mobility.utils.upf",
        "documentation": {}
    },
    {
        "label": "MatdynWorkChain",
        "kind": 6,
        "importPath": "aiida_mobility.workflows.matdyn.matdyn_workflow",
        "description": "aiida_mobility.workflows.matdyn.matdyn_workflow",
        "peekOfCode": "class MatdynWorkChain(WorkChain):\n    @classmethod\n    def define(cls, spec):\n        super().define(spec)\n        spec.expose_inputs(\n            PwRelaxWorkChain,\n            namespace=\"relax\",\n            exclude=(\"clean_workdir\", \"structure\"),\n            namespace_options={\n                \"required\": False,",
        "detail": "aiida_mobility.workflows.matdyn.matdyn_workflow",
        "documentation": {}
    },
    {
        "label": "validate_inputs",
        "kind": 2,
        "importPath": "aiida_mobility.workflows.matdyn.matdyn_workflow",
        "description": "aiida_mobility.workflows.matdyn.matdyn_workflow",
        "peekOfCode": "def validate_inputs(inputs, ctx=None):  # pylint: disable=unused-argument\n    \"\"\"Validate the inputs of the entire input namespace.\"\"\"\n    if \"scf_node\" in inputs:\n        try:\n            scf = load_node(inputs[\"scf_node\"].value)\n            remote = scf.outputs.remote_folder\n        except Exception:\n            return MatdynWorkChain.exit_codes.ERROR_INVALID_SCF_NODE.message\n    if \"ph_node\" in inputs:\n        try:",
        "detail": "aiida_mobility.workflows.matdyn.matdyn_workflow",
        "documentation": {}
    },
    {
        "label": "PertuborWorkChain",
        "kind": 6,
        "importPath": "aiida_mobility.workflows.mobility.mobility",
        "description": "aiida_mobility.workflows.mobility.mobility",
        "peekOfCode": "class PertuborWorkChain(WorkChain):\n    @classmethod\n    def define(cls, spec):\n        super().define(spec)\n        spec.input(\n            \"structure\",\n            valid_type=orm.StructureData,\n            help=\"The inputs structure.\",\n        )\n        spec.expose_inputs(",
        "detail": "aiida_mobility.workflows.mobility.mobility",
        "documentation": {}
    },
    {
        "label": "validate_inputs",
        "kind": 2,
        "importPath": "aiida_mobility.workflows.mobility.mobility",
        "description": "aiida_mobility.workflows.mobility.mobility",
        "peekOfCode": "def validate_inputs(inputs, ctx=None):  # pylint: disable=unused-argument\n    pass\nclass PertuborWorkChain(WorkChain):\n    @classmethod\n    def define(cls, spec):\n        super().define(spec)\n        spec.input(\n            \"structure\",\n            valid_type=orm.StructureData,\n            help=\"The inputs structure.\",",
        "detail": "aiida_mobility.workflows.mobility.mobility",
        "documentation": {}
    },
    {
        "label": "PertuborWorkChain",
        "kind": 6,
        "importPath": "aiida_mobility.workflows.mobility.perturbo",
        "description": "aiida_mobility.workflows.mobility.perturbo",
        "peekOfCode": "class PertuborWorkChain(WorkChain):\n    _QE_DVSCF_PREFIX = QE2PertCalculation._QE_DVSCF_PREFIX\n    _DEFAULT_SETTINGS = {}\n    _DEFAULT_METADATA_OPTIONS = {\n        \"resources\": {\n            \"num_machines\": 1,\n            \"num_mpiprocs_per_machine\": 1,\n        },\n        \"withmpi\": False,\n    }",
        "detail": "aiida_mobility.workflows.mobility.perturbo",
        "documentation": {}
    },
    {
        "label": "validate_inputs",
        "kind": 2,
        "importPath": "aiida_mobility.workflows.mobility.perturbo",
        "description": "aiida_mobility.workflows.mobility.perturbo",
        "peekOfCode": "def validate_inputs(inputs, ctx=None):  # pylint: disable=unused-argument\n    pass\nclass PertuborWorkChain(WorkChain):\n    _QE_DVSCF_PREFIX = QE2PertCalculation._QE_DVSCF_PREFIX\n    _DEFAULT_SETTINGS = {}\n    _DEFAULT_METADATA_OPTIONS = {\n        \"resources\": {\n            \"num_machines\": 1,\n            \"num_mpiprocs_per_machine\": 1,\n        },",
        "detail": "aiida_mobility.workflows.mobility.perturbo",
        "documentation": {}
    },
    {
        "label": "get_bands_info",
        "kind": 2,
        "importPath": "aiida_mobility.workflows.mobility.perturbo",
        "description": "aiida_mobility.workflows.mobility.perturbo",
        "peekOfCode": "def get_bands_info(bands, fermi_energy, distance=0.3):\n    bands_info = {\"fermi_energy\": fermi_energy}\n    # if np.isclose(np.min(np.abs(bands - fermi_energy)), 0):\n    bound = bands[bands < fermi_energy].shape[0] / bands.shape[0]\n    if bound % 1 != 0:  # metal\n        # raise ValueError(\"The fermi level is over some bands.\")\n        calc_bands = []\n        for i in range(0, bands.shape[1]):\n            band = bands[:, i]\n            if np.min(np.abs(band - fermi_energy)) < distance:",
        "detail": "aiida_mobility.workflows.mobility.perturbo",
        "documentation": {}
    },
    {
        "label": "PhBandsWorkChain",
        "kind": 6,
        "importPath": "aiida_mobility.workflows.ph.bands",
        "description": "aiida_mobility.workflows.ph.bands",
        "peekOfCode": "class PhBandsWorkChain(WorkChain):\n    @classmethod\n    def define(cls, spec):\n        super().define(spec)\n        spec.expose_inputs(\n            PwRelaxWorkChain,\n            namespace=\"relax\",\n            exclude=(\"clean_workdir\", \"structure\"),\n            namespace_options={\n                \"required\": False,",
        "detail": "aiida_mobility.workflows.ph.bands",
        "documentation": {}
    },
    {
        "label": "validate_inputs",
        "kind": 2,
        "importPath": "aiida_mobility.workflows.ph.bands",
        "description": "aiida_mobility.workflows.ph.bands",
        "peekOfCode": "def validate_inputs(inputs, ctx=None):  # pylint: disable=unused-argument\n    \"\"\"Validate the inputs of the entire input namespace.\"\"\"\n    if \"scf_node\" in inputs:\n        try:\n            scf = load_node(inputs[\"scf_node\"].value)\n            remote = scf.outputs.remote_folder\n        except Exception:\n            return PhBandsWorkChain.exit_codes.ERROR_INVALID_SCF_NODE.message\n    if \"ph_node\" in inputs:\n        try:",
        "detail": "aiida_mobility.workflows.ph.bands",
        "documentation": {}
    },
    {
        "label": "PhBaseWorkChain",
        "kind": 6,
        "importPath": "aiida_mobility.workflows.ph.base",
        "description": "aiida_mobility.workflows.ph.base",
        "peekOfCode": "class PhBaseWorkChain(BaseRestartWorkChain):\n    \"\"\"Workchain to run a Quantum ESPRESSO ph.x calculation with automated error handling and restarts.\"\"\"\n    _process_class = PhCalculation\n    defaults = AttributeDict(\n        {\n            \"delta_factor_max_seconds\": 0.95,\n            \"delta_factor_alpha_mix\": 0.90,\n            \"alpha_mix\": 0.70,\n        }\n    )",
        "detail": "aiida_mobility.workflows.ph.base",
        "documentation": {}
    },
    {
        "label": "PhCalculation",
        "kind": 5,
        "importPath": "aiida_mobility.workflows.ph.base",
        "description": "aiida_mobility.workflows.ph.base",
        "peekOfCode": "PhCalculation = CalculationFactory(\"quantumespresso.ph\")\nPwCalculation = CalculationFactory(\"quantumespresso.pw\")\nclass PhBaseWorkChain(BaseRestartWorkChain):\n    \"\"\"Workchain to run a Quantum ESPRESSO ph.x calculation with automated error handling and restarts.\"\"\"\n    _process_class = PhCalculation\n    defaults = AttributeDict(\n        {\n            \"delta_factor_max_seconds\": 0.95,\n            \"delta_factor_alpha_mix\": 0.90,\n            \"alpha_mix\": 0.70,",
        "detail": "aiida_mobility.workflows.ph.base",
        "documentation": {}
    },
    {
        "label": "PwCalculation",
        "kind": 5,
        "importPath": "aiida_mobility.workflows.ph.base",
        "description": "aiida_mobility.workflows.ph.base",
        "peekOfCode": "PwCalculation = CalculationFactory(\"quantumespresso.pw\")\nclass PhBaseWorkChain(BaseRestartWorkChain):\n    \"\"\"Workchain to run a Quantum ESPRESSO ph.x calculation with automated error handling and restarts.\"\"\"\n    _process_class = PhCalculation\n    defaults = AttributeDict(\n        {\n            \"delta_factor_max_seconds\": 0.95,\n            \"delta_factor_alpha_mix\": 0.90,\n            \"alpha_mix\": 0.70,\n        }",
        "detail": "aiida_mobility.workflows.ph.base",
        "documentation": {}
    },
    {
        "label": "PwBandStructureWorkChain",
        "kind": 6,
        "importPath": "aiida_mobility.workflows.pw.band_structure",
        "description": "aiida_mobility.workflows.pw.band_structure",
        "peekOfCode": "class PwBandStructureWorkChain(WorkChain):\n    \"\"\"Workchain to automatically compute a band structure for a given structure using Quantum ESPRESSO pw.x.\"\"\"\n    @classmethod\n    def define(cls, spec):\n        \"\"\"Define the process specification.\"\"\"\n        # yapf: disable\n        super(PwBandStructureWorkChain, cls).define(spec)\n        spec.input('code', valid_type=orm.Code,\n                   help='The `pw.x` code to use for the `PwCalculations`.')\n        spec.input('structure', valid_type=orm.StructureData,",
        "detail": "aiida_mobility.workflows.pw.band_structure",
        "documentation": {}
    },
    {
        "label": "validate_protocol",
        "kind": 2,
        "importPath": "aiida_mobility.workflows.pw.band_structure",
        "description": "aiida_mobility.workflows.pw.band_structure",
        "peekOfCode": "def validate_protocol(protocol_dict):\n    \"\"\"Check that the protocol is one for which we have a definition.\"\"\"\n    try:\n        protocol_name = protocol_dict['name']\n    except KeyError as exception:\n        return 'Missing key `name` in protocol dictionary'\n    try:\n        ProtocolManager(protocol_name)\n    except ValueError as exception:\n        return str(exception)",
        "detail": "aiida_mobility.workflows.pw.band_structure",
        "documentation": {}
    },
    {
        "label": "validate_cutoffs",
        "kind": 2,
        "importPath": "aiida_mobility.workflows.pw.band_structure",
        "description": "aiida_mobility.workflows.pw.band_structure",
        "peekOfCode": "def validate_cutoffs(cutoffs_dict, ctx):\n    try:\n        cutoff = cutoffs_dict['cutoff']\n        dual = cutoffs_dict['dual']\n    except KeyError as exception:\n        return 'Missing key `cutoff` or `dual` in cutoffs dictionary'\n    except TypeError:\n        pass\nclass PwBandStructureWorkChain(WorkChain):\n    \"\"\"Workchain to automatically compute a band structure for a given structure using Quantum ESPRESSO pw.x.\"\"\"",
        "detail": "aiida_mobility.workflows.pw.band_structure",
        "documentation": {}
    },
    {
        "label": "PwBandsWorkChain",
        "kind": 6,
        "importPath": "aiida_mobility.workflows.pw.bands",
        "description": "aiida_mobility.workflows.pw.bands",
        "peekOfCode": "class PwBandsWorkChain(ProtocolMixin, WorkChain):\n    \"\"\"Workchain to compute a band structure for a given structure using Quantum ESPRESSO pw.x.\n    The logic for the computation of various parameters for the BANDS step is as follows:\n    Number of bands:\n        One can specify the number of bands to be used in the BANDS step either directly through the input parameters\n        `bands.pw.parameters.SYSTEM.nbnd` or through `nbands_factor`. Note that specifying both is not allowed. When\n        neither is specified nothing will be set by the work chain and the default of Quantum ESPRESSO will end up being\n        used. If the `nbands_factor` is specified the maximum value of the following values will be used:\n        * `nbnd` of the preceding SCF calculation\n        * 0.5 * nspin * nelectrons * nbands_factor",
        "detail": "aiida_mobility.workflows.pw.bands",
        "documentation": {}
    },
    {
        "label": "validate_inputs",
        "kind": 2,
        "importPath": "aiida_mobility.workflows.pw.bands",
        "description": "aiida_mobility.workflows.pw.bands",
        "peekOfCode": "def validate_inputs(inputs, ctx=None):  # pylint: disable=unused-argument\n    \"\"\"Validate the inputs of the entire input namespace.\"\"\"\n    # pylint: disable=no-member\n    if \"nbands_factor\" in inputs and \"nbnd\" in inputs[\"bands\"][\"pw\"][\n        \"parameters\"\n    ].get_attribute(\"SYSTEM\", {}):\n        return (\n            PwBandsWorkChain.exit_codes.ERROR_INVALID_INPUT_NUMBER_OF_BANDS.message\n        )\n    # Cannot specify both `bands_kpoints` and `bands_kpoints_distance`",
        "detail": "aiida_mobility.workflows.pw.bands",
        "documentation": {}
    },
    {
        "label": "PwBaseWorkChain",
        "kind": 6,
        "importPath": "aiida_mobility.workflows.pw.base",
        "description": "aiida_mobility.workflows.pw.base",
        "peekOfCode": "class PwBaseWorkChain(ProtocolMixin, BaseRestartWorkChain):\n    \"\"\"Workchain to run a Quantum ESPRESSO pw.x calculation with automated error handling and restarts.\"\"\"\n    # pylint: disable=too-many-public-methods\n    _process_class = PwCalculation\n    defaults = AttributeDict(\n        {\n            \"qe\": qe_defaults,\n            \"delta_threshold_degauss\": 30,\n            \"delta_factor_degauss\": 0.1,\n            \"delta_factor_mixing_beta\": 0.8,",
        "detail": "aiida_mobility.workflows.pw.base",
        "documentation": {}
    },
    {
        "label": "validate_pseudo_family",
        "kind": 2,
        "importPath": "aiida_mobility.workflows.pw.base",
        "description": "aiida_mobility.workflows.pw.base",
        "peekOfCode": "def validate_pseudo_family(value, _):\n    \"\"\"Validate the `pseudo_family` input.\"\"\"\n    if value:\n        import warnings\n        from aiida.common.warnings import AiidaDeprecationWarning\n        warnings.warn(\n            \"`pseudo_family` is deprecated, use `pw.pseudos` instead.\",\n            AiidaDeprecationWarning,\n        )\nclass PwBaseWorkChain(ProtocolMixin, BaseRestartWorkChain):",
        "detail": "aiida_mobility.workflows.pw.base",
        "documentation": {}
    },
    {
        "label": "PwCalculation",
        "kind": 5,
        "importPath": "aiida_mobility.workflows.pw.base",
        "description": "aiida_mobility.workflows.pw.base",
        "peekOfCode": "PwCalculation = CalculationFactory(\"quantumespresso.pw\")\nSsspFamily = GroupFactory(\"pseudo.family.sssp\")\nPseudoDojoFamily = GroupFactory(\"pseudo.family.pseudo_dojo\")\ndef validate_pseudo_family(value, _):\n    \"\"\"Validate the `pseudo_family` input.\"\"\"\n    if value:\n        import warnings\n        from aiida.common.warnings import AiidaDeprecationWarning\n        warnings.warn(\n            \"`pseudo_family` is deprecated, use `pw.pseudos` instead.\",",
        "detail": "aiida_mobility.workflows.pw.base",
        "documentation": {}
    },
    {
        "label": "SsspFamily",
        "kind": 5,
        "importPath": "aiida_mobility.workflows.pw.base",
        "description": "aiida_mobility.workflows.pw.base",
        "peekOfCode": "SsspFamily = GroupFactory(\"pseudo.family.sssp\")\nPseudoDojoFamily = GroupFactory(\"pseudo.family.pseudo_dojo\")\ndef validate_pseudo_family(value, _):\n    \"\"\"Validate the `pseudo_family` input.\"\"\"\n    if value:\n        import warnings\n        from aiida.common.warnings import AiidaDeprecationWarning\n        warnings.warn(\n            \"`pseudo_family` is deprecated, use `pw.pseudos` instead.\",\n            AiidaDeprecationWarning,",
        "detail": "aiida_mobility.workflows.pw.base",
        "documentation": {}
    },
    {
        "label": "PseudoDojoFamily",
        "kind": 5,
        "importPath": "aiida_mobility.workflows.pw.base",
        "description": "aiida_mobility.workflows.pw.base",
        "peekOfCode": "PseudoDojoFamily = GroupFactory(\"pseudo.family.pseudo_dojo\")\ndef validate_pseudo_family(value, _):\n    \"\"\"Validate the `pseudo_family` input.\"\"\"\n    if value:\n        import warnings\n        from aiida.common.warnings import AiidaDeprecationWarning\n        warnings.warn(\n            \"`pseudo_family` is deprecated, use `pw.pseudos` instead.\",\n            AiidaDeprecationWarning,\n        )",
        "detail": "aiida_mobility.workflows.pw.base",
        "documentation": {}
    },
    {
        "label": "PwRelaxWorkChain",
        "kind": 6,
        "importPath": "aiida_mobility.workflows.pw.relax",
        "description": "aiida_mobility.workflows.pw.relax",
        "peekOfCode": "class PwRelaxWorkChain(ProtocolMixin, WorkChain):\n    \"\"\"Workchain to relax a structure using Quantum ESPRESSO pw.x.\"\"\"\n    @classmethod\n    def define(cls, spec):\n        \"\"\"Define the process specification.\"\"\"\n        # yapf: disable\n        super().define(spec)\n        spec.expose_inputs(PwBaseWorkChain, namespace='base',\n                           exclude=('clean_workdir', 'pw.structure',\n                                    'pw.parent_folder'),",
        "detail": "aiida_mobility.workflows.pw.relax",
        "documentation": {}
    },
    {
        "label": "validate_inputs",
        "kind": 2,
        "importPath": "aiida_mobility.workflows.pw.relax",
        "description": "aiida_mobility.workflows.pw.relax",
        "peekOfCode": "def validate_inputs(inputs, _):\n    \"\"\"Validate the top level namespace.\"\"\"\n    parameters = inputs[\"base\"][\"pw\"][\"parameters\"].get_dict()\n    if (\n        \"relaxation_scheme\" not in inputs\n        and \"calculation\" not in parameters.get(\"CONTROL\", {})\n    ):\n        return \"The parameters in `base.pw.parameters` do not specify the required key `CONTROL.calculation`.\"\ndef validate_final_scf(value, _):\n    \"\"\"Validate the final scf input.\"\"\"",
        "detail": "aiida_mobility.workflows.pw.relax",
        "documentation": {}
    },
    {
        "label": "validate_final_scf",
        "kind": 2,
        "importPath": "aiida_mobility.workflows.pw.relax",
        "description": "aiida_mobility.workflows.pw.relax",
        "peekOfCode": "def validate_final_scf(value, _):\n    \"\"\"Validate the final scf input.\"\"\"\n    if isinstance(value, orm.Bool) and value:\n        import warnings\n        from aiida.common.warnings import AiidaDeprecationWarning\n        warnings.warn(\n            \"this input is deprecated and will be removed. If you want to run a final scf, specify the inputs that \"\n            \"should be used in the `base_final_scf` namespace.\",\n            AiidaDeprecationWarning,\n        )",
        "detail": "aiida_mobility.workflows.pw.relax",
        "documentation": {}
    },
    {
        "label": "validate_relaxation_scheme",
        "kind": 2,
        "importPath": "aiida_mobility.workflows.pw.relax",
        "description": "aiida_mobility.workflows.pw.relax",
        "peekOfCode": "def validate_relaxation_scheme(value, _):\n    \"\"\"Validate the relaxation scheme input.\"\"\"\n    if value:\n        import warnings\n        from aiida.common.warnings import AiidaDeprecationWarning\n        warnings.warn(\n            \"the `relaxation_scheme` input is deprecated and will be removed. Use the `get_builder_from_protocol` \"\n            \"instead to obtain a prepopulated builder using the `RelaxType` enum.\",\n            AiidaDeprecationWarning,\n        )",
        "detail": "aiida_mobility.workflows.pw.relax",
        "documentation": {}
    },
    {
        "label": "PwCalculation",
        "kind": 5,
        "importPath": "aiida_mobility.workflows.pw.relax",
        "description": "aiida_mobility.workflows.pw.relax",
        "peekOfCode": "PwCalculation = CalculationFactory(\"quantumespresso.pw\")\ndef validate_inputs(inputs, _):\n    \"\"\"Validate the top level namespace.\"\"\"\n    parameters = inputs[\"base\"][\"pw\"][\"parameters\"].get_dict()\n    if (\n        \"relaxation_scheme\" not in inputs\n        and \"calculation\" not in parameters.get(\"CONTROL\", {})\n    ):\n        return \"The parameters in `base.pw.parameters` do not specify the required key `CONTROL.calculation`.\"\ndef validate_final_scf(value, _):",
        "detail": "aiida_mobility.workflows.pw.relax",
        "documentation": {}
    },
    {
        "label": "Wannier90BandsWorkChain",
        "kind": 6,
        "importPath": "aiida_mobility.workflows.wannier.bands",
        "description": "aiida_mobility.workflows.wannier.bands",
        "peekOfCode": "class Wannier90BandsWorkChain(WorkChain):\n    \"\"\"\n    A high level workchain which can automatically compute a Wannier band structure for a given structure. Can also output Wannier Hamiltonian.\n    \"\"\"\n    @classmethod\n    def define(cls, spec):\n        \"\"\"Define the process specification.\"\"\"\n        super().define(spec)\n        spec.input_namespace(\"codes\", required=True, valid_type=orm.Code)\n        spec.input(",
        "detail": "aiida_mobility.workflows.wannier.bands",
        "documentation": {}
    },
    {
        "label": "get_default_options",
        "kind": 2,
        "importPath": "aiida_mobility.workflows.wannier.bands",
        "description": "aiida_mobility.workflows.wannier.bands",
        "peekOfCode": "def get_default_options(structure, with_mpi=False):\n    \"\"\"Increase wallclock to 5 hour, use mpi, set number of machines according to\n    number of atoms.\n    :param with_mpi: [description], defaults to False\n    :type with_mpi: bool, optional\n    :return: [description]\n    :rtype: [type]\n    \"\"\"\n    def estimate_num_machines(structure):\n        \"\"\"",
        "detail": "aiida_mobility.workflows.wannier.bands",
        "documentation": {}
    },
    {
        "label": "validate_protocol",
        "kind": 2,
        "importPath": "aiida_mobility.workflows.wannier.bands",
        "description": "aiida_mobility.workflows.wannier.bands",
        "peekOfCode": "def validate_protocol(protocol_dict, ctx):\n    \"\"\"Check that the protocol is one for which we have a definition.\"\"\"\n    try:\n        protocol_name = protocol_dict[\"name\"]\n    except KeyError as exception:\n        return \"Missing key `name` in protocol dictionary\"\n    try:\n        ProtocolManager(protocol_name)\n    except ValueError as exception:\n        return str(exception)",
        "detail": "aiida_mobility.workflows.wannier.bands",
        "documentation": {}
    },
    {
        "label": "validate_cutoffs",
        "kind": 2,
        "importPath": "aiida_mobility.workflows.wannier.bands",
        "description": "aiida_mobility.workflows.wannier.bands",
        "peekOfCode": "def validate_cutoffs(cutoffs_dict, ctx):\n    try:\n        cutoff = cutoffs_dict[\"cutoff\"]\n        dual = cutoffs_dict[\"dual\"]\n    except KeyError as exception:\n        return \"Missing key `cutoff` or `dual` in cutoffs dictionary\"\n    except TypeError:\n        pass\ndef get_manual_options():\n    # QE projwfc.x complains",
        "detail": "aiida_mobility.workflows.wannier.bands",
        "documentation": {}
    },
    {
        "label": "get_manual_options",
        "kind": 2,
        "importPath": "aiida_mobility.workflows.wannier.bands",
        "description": "aiida_mobility.workflows.wannier.bands",
        "peekOfCode": "def get_manual_options():\n    # QE projwfc.x complains\n    #         Calling projwave ....\n    #     linear algebra parallelized on  16 procs\n    # Problem Sizes\n    # natomwfc =           14\n    # nx       =            4\n    # nbnd     =           24\n    # nkstot   =          216\n    # npwx     =           83",
        "detail": "aiida_mobility.workflows.wannier.bands",
        "documentation": {}
    },
    {
        "label": "Wannier90BaseWorkChain",
        "kind": 6,
        "importPath": "aiida_mobility.workflows.wannier.base",
        "description": "aiida_mobility.workflows.wannier.base",
        "peekOfCode": "class Wannier90BaseWorkChain(BaseRestartWorkChain):\n    \"\"\"Workchain to run a wannier90 calculation with automated error handling and restarts.\"\"\"\n    _process_class = Wannier90Calculation\n    _WANNIER90_DEFAULT_KMESH_TOL = 1e-6\n    @classmethod\n    def define(cls, spec):\n        super().define(spec)\n        spec.expose_inputs(Wannier90Calculation, namespace=\"wannier90\")\n        spec.outline(\n            cls.setup,",
        "detail": "aiida_mobility.workflows.wannier.base",
        "documentation": {}
    },
    {
        "label": "Wannier90WorkChain",
        "kind": 6,
        "importPath": "aiida_mobility.workflows.wannier.wannier",
        "description": "aiida_mobility.workflows.wannier.wannier",
        "peekOfCode": "class Wannier90WorkChain(WorkChain):\n    \"\"\"\n    Workchain to obtain maximally localised Wannier functions (MLWF)\n    Authors: Antimo Marrazzo (antimo.marrazzo@epfl.ch), Giovanni Pizzi (giovanni.pizzi@epfl.ch), Junfeng Qiao(junfeng.qiao@epfl.ch)\n    MIT License - Copyright (c), 2018, ECOLE POLYTECHNIQUE FEDERALE DE LAUSANNE\n    (Theory and Simulation of Materials (THEOS) and National Centre for\n    Computational Design and Discovery of Novel Materials (NCCR MARVEL)).\n    All rights reserved.\n    Scheme: setup --> relax(optional) --> scf --> nscf --> projwfc\n            -> wannier90_postproc --> pw2wannier90 --> wannier90 --> results",
        "detail": "aiida_mobility.workflows.wannier.wannier",
        "documentation": {}
    },
    {
        "label": "get_fermi_energy",
        "kind": 2,
        "importPath": "aiida_mobility.workflows.wannier.wannier",
        "description": "aiida_mobility.workflows.wannier.wannier",
        "peekOfCode": "def get_fermi_energy(output_parameters):\n    \"\"\"get Fermi energy from scf output parameters, unit is eV\n    :param output_parameters: scf output parameters\n    :type output_parameters: orm.Dict\n    :return: if found return Fermi energy, else None\n    :rtype: float, None\n    \"\"\"\n    out_dict = output_parameters.get_dict()\n    fermi = out_dict.get(\"fermi_energy\", None)\n    fermi_units = out_dict.get(\"fermi_energy_units\", None)",
        "detail": "aiida_mobility.workflows.wannier.wannier",
        "documentation": {}
    },
    {
        "label": "update_fermi_energy",
        "kind": 2,
        "importPath": "aiida_mobility.workflows.wannier.wannier",
        "description": "aiida_mobility.workflows.wannier.wannier",
        "peekOfCode": "def update_fermi_energy(wannier_input_parameters, scf_output_parameters):\n    \"\"\"extract Fermi energy from scf calculation and add it to Wannier input parameters\n    :param wannier_input_parameters: Wannier input parameters\n    :type wannier_input_parameters: orm.Dict\n    :param scf_output_parameters: scf output parameters\n    :type scf_output_parameters: orm.Dict\n    \"\"\"\n    params = wannier_input_parameters.get_dict()\n    fermi = get_fermi_energy(scf_output_parameters)\n    params[\"fermi_energy\"] = fermi",
        "detail": "aiida_mobility.workflows.wannier.wannier",
        "documentation": {}
    },
    {
        "label": "update_scdm_mu_sigma",
        "kind": 2,
        "importPath": "aiida_mobility.workflows.wannier.wannier",
        "description": "aiida_mobility.workflows.wannier.wannier",
        "peekOfCode": "def update_scdm_mu_sigma(parameters, bands, projections, thresholds):\n    \"\"\"Use erfc fitting to extract scdm_mu & scdm_sigma, and update the pw2wannier90 input parameters.\n    :param parameters: pw2wannier90 input parameters\n    :type parameters: aiida.orm.Dict\n    :param bands: band structure\n    :type bands: aiida.orm.BandsData\n    :param projections: projectability from projwfc.x\n    :type projections: aiida.orm.ProjectionData\n    :param thresholds: sigma shift factor\n    :type thresholds: aiida.orm.Dict",
        "detail": "aiida_mobility.workflows.wannier.wannier",
        "documentation": {}
    },
    {
        "label": "Wannier90OpengridWorkChain",
        "kind": 6,
        "importPath": "aiida_mobility.workflows.opengrid",
        "description": "aiida_mobility.workflows.opengrid",
        "peekOfCode": "class Wannier90OpengridWorkChain(Wannier90WorkChain):\n    \"\"\"This WorkChain uses open_grid.x to unfold the\n    symmetrized kmesh to a full kmesh in the Wannier90WorkChain.\n    The full-kmesh nscf can be avoided.\n    2 schemes:\n    1. scf w/ symmetry, more nbnd -> open_grid\n       -> pw2wannier90 -> wannier90\n    2. scf w/ symmetry, default nbnd -> nscf w/ symm, more nbnd\n       -> open_grid -> pw2wannier90 -> wannier90\n    :param Wannier90WorkChain: [description]",
        "detail": "aiida_mobility.workflows.opengrid",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "aiida_mobility.workflows.opengrid",
        "description": "aiida_mobility.workflows.opengrid",
        "peekOfCode": "__all__ = [\"Wannier90OpengridWorkChain\"]\nclass Wannier90OpengridWorkChain(Wannier90WorkChain):\n    \"\"\"This WorkChain uses open_grid.x to unfold the\n    symmetrized kmesh to a full kmesh in the Wannier90WorkChain.\n    The full-kmesh nscf can be avoided.\n    2 schemes:\n    1. scf w/ symmetry, more nbnd -> open_grid\n       -> pw2wannier90 -> wannier90\n    2. scf w/ symmetry, default nbnd -> nscf w/ symm, more nbnd\n       -> open_grid -> pw2wannier90 -> wannier90",
        "detail": "aiida_mobility.workflows.opengrid",
        "documentation": {}
    },
    {
        "label": "parse_arugments",
        "kind": 2,
        "importPath": "examples.matdyn.run_matdyn_base",
        "description": "examples.matdyn.run_matdyn_base",
        "peekOfCode": "def parse_arugments():\n    parser = argparse.ArgumentParser(\n        description=\"A script to run the AiiDA matdyn calculation.\"\n    )\n    parser.add_argument(\n        \"-S\",\n        \"--structure\",\n        metavar=\"FILENAME\",\n        help=\"path to an input Structure(xsf,cif,poscar) file\",\n        required=True,",
        "detail": "examples.matdyn.run_matdyn_base",
        "documentation": {}
    },
    {
        "label": "gen_kpoints",
        "kind": 2,
        "importPath": "examples.matdyn.run_matdyn_base",
        "description": "examples.matdyn.run_matdyn_base",
        "peekOfCode": "def gen_kpoints(structure, distance, two_d=False):\n    from aiida_quantumespresso.calculations.functions.seekpath_structure_analysis import (\n        seekpath_structure_analysis,\n    )\n    from aiida_mobility.utils import constr2dpath\n    inputs = {\n        \"reference_distance\": distance,\n        \"metadata\": {\"call_link_label\": \"seekpath\"},\n    }\n    result = seekpath_structure_analysis(structure, **inputs)",
        "detail": "examples.matdyn.run_matdyn_base",
        "documentation": {}
    },
    {
        "label": "submit_workchain",
        "kind": 2,
        "importPath": "examples.matdyn.run_matdyn_base",
        "description": "examples.matdyn.run_matdyn_base",
        "peekOfCode": "def submit_workchain(\n    structure_file,\n    q2r,\n    asr,\n    distance,\n    system_2d,\n    num_machines,\n    num_mpiprocs_per_machine,\n    walltime,\n    matdyn_code,",
        "detail": "examples.matdyn.run_matdyn_base",
        "documentation": {}
    },
    {
        "label": "str_matdyn",
        "kind": 5,
        "importPath": "examples.matdyn.run_matdyn_base",
        "description": "examples.matdyn.run_matdyn_base",
        "peekOfCode": "str_matdyn = \"qe-6.5-matdyn\"\ndef parse_arugments():\n    parser = argparse.ArgumentParser(\n        description=\"A script to run the AiiDA matdyn calculation.\"\n    )\n    parser.add_argument(\n        \"-S\",\n        \"--structure\",\n        metavar=\"FILENAME\",\n        help=\"path to an input Structure(xsf,cif,poscar) file\",",
        "detail": "examples.matdyn.run_matdyn_base",
        "documentation": {}
    },
    {
        "label": "parse_arugments",
        "kind": 2,
        "importPath": "examples.matdyn.run_matdyn_workflow",
        "description": "examples.matdyn.run_matdyn_workflow",
        "peekOfCode": "def parse_arugments():\n    parser = argparse.ArgumentParser(\n        description=\"A script to run the AiiDA workflows to automatically compute the Phono Dispersion.\"\n    )\n    group = parser.add_mutually_exclusive_group(required=True)\n    parser.add_argument(\n        \"-S\",\n        \"--structure\",\n        metavar=\"FILENAME\",\n        help=\"path to an input Structure(xsf,cif,poscar) file\",",
        "detail": "examples.matdyn.run_matdyn_workflow",
        "documentation": {}
    },
    {
        "label": "get_options",
        "kind": 2,
        "importPath": "examples.matdyn.run_matdyn_workflow",
        "description": "examples.matdyn.run_matdyn_workflow",
        "peekOfCode": "def get_options(num_machines, num_mpiprocs_per_machine, walltime=5):\n    return {\n        \"resources\": {\n            \"num_machines\": num_machines,\n            \"num_mpiprocs_per_machine\": num_mpiprocs_per_machine,\n        },\n        \"max_wallclock_seconds\": 3600 * walltime,\n        \"withmpi\": True,\n    }\ndef submit_workchain(",
        "detail": "examples.matdyn.run_matdyn_workflow",
        "documentation": {}
    },
    {
        "label": "submit_workchain",
        "kind": 2,
        "importPath": "examples.matdyn.run_matdyn_workflow",
        "description": "examples.matdyn.run_matdyn_workflow",
        "peekOfCode": "def submit_workchain(\n    structure_file,\n    scf_parameters_name,\n    protocol,\n    pseudos,\n    pseudo_family,\n    cutoffs,\n    system_2d,\n    run_relax,\n    tr2_ph,",
        "detail": "examples.matdyn.run_matdyn_workflow",
        "documentation": {}
    },
    {
        "label": "str_pw",
        "kind": 5,
        "importPath": "examples.matdyn.run_matdyn_workflow",
        "description": "examples.matdyn.run_matdyn_workflow",
        "peekOfCode": "str_pw = \"qe-6.5-pw\"\nstr_ph = \"qe-6.5-ph\"\nstr_q2r = \"qe-6.5-q2r\"\nstr_matdyn = \"qe-6.5-matdyn\"\ndef parse_arugments():\n    parser = argparse.ArgumentParser(\n        description=\"A script to run the AiiDA workflows to automatically compute the Phono Dispersion.\"\n    )\n    group = parser.add_mutually_exclusive_group(required=True)\n    parser.add_argument(",
        "detail": "examples.matdyn.run_matdyn_workflow",
        "documentation": {}
    },
    {
        "label": "str_ph",
        "kind": 5,
        "importPath": "examples.matdyn.run_matdyn_workflow",
        "description": "examples.matdyn.run_matdyn_workflow",
        "peekOfCode": "str_ph = \"qe-6.5-ph\"\nstr_q2r = \"qe-6.5-q2r\"\nstr_matdyn = \"qe-6.5-matdyn\"\ndef parse_arugments():\n    parser = argparse.ArgumentParser(\n        description=\"A script to run the AiiDA workflows to automatically compute the Phono Dispersion.\"\n    )\n    group = parser.add_mutually_exclusive_group(required=True)\n    parser.add_argument(\n        \"-S\",",
        "detail": "examples.matdyn.run_matdyn_workflow",
        "documentation": {}
    },
    {
        "label": "str_q2r",
        "kind": 5,
        "importPath": "examples.matdyn.run_matdyn_workflow",
        "description": "examples.matdyn.run_matdyn_workflow",
        "peekOfCode": "str_q2r = \"qe-6.5-q2r\"\nstr_matdyn = \"qe-6.5-matdyn\"\ndef parse_arugments():\n    parser = argparse.ArgumentParser(\n        description=\"A script to run the AiiDA workflows to automatically compute the Phono Dispersion.\"\n    )\n    group = parser.add_mutually_exclusive_group(required=True)\n    parser.add_argument(\n        \"-S\",\n        \"--structure\",",
        "detail": "examples.matdyn.run_matdyn_workflow",
        "documentation": {}
    },
    {
        "label": "str_matdyn",
        "kind": 5,
        "importPath": "examples.matdyn.run_matdyn_workflow",
        "description": "examples.matdyn.run_matdyn_workflow",
        "peekOfCode": "str_matdyn = \"qe-6.5-matdyn\"\ndef parse_arugments():\n    parser = argparse.ArgumentParser(\n        description=\"A script to run the AiiDA workflows to automatically compute the Phono Dispersion.\"\n    )\n    group = parser.add_mutually_exclusive_group(required=True)\n    parser.add_argument(\n        \"-S\",\n        \"--structure\",\n        metavar=\"FILENAME\",",
        "detail": "examples.matdyn.run_matdyn_workflow",
        "documentation": {}
    },
    {
        "label": "parse_arugments",
        "kind": 2,
        "importPath": "examples.ph.run_ph_bands",
        "description": "examples.ph.run_ph_bands",
        "peekOfCode": "def parse_arugments():\n    parser = argparse.ArgumentParser(\n        description=\"A script to run the AiiDA workflows to automatically compute the Phono Dispersion.\"\n    )\n    group = parser.add_mutually_exclusive_group(required=True)\n    parser.add_argument(\n        \"-S\",\n        \"--structure\",\n        metavar=\"FILENAME\",\n        help=\"path to an input Structure(xsf,cif,poscar) file\",",
        "detail": "examples.ph.run_ph_bands",
        "documentation": {}
    },
    {
        "label": "submit_workchain",
        "kind": 2,
        "importPath": "examples.ph.run_ph_bands",
        "description": "examples.ph.run_ph_bands",
        "peekOfCode": "def submit_workchain(\n    structure_file,\n    scf_parameters_name,\n    protocol,\n    pseudos,\n    pseudo_family,\n    kpoints_mesh,\n    cutoffs,\n    system_2d,\n    run_relax,",
        "detail": "examples.ph.run_ph_bands",
        "documentation": {}
    },
    {
        "label": "str_pw",
        "kind": 5,
        "importPath": "examples.ph.run_ph_bands",
        "description": "examples.ph.run_ph_bands",
        "peekOfCode": "str_pw = \"qe-6.5-pw\"\nstr_ph = \"qe-6.5-ph\"\nstr_q2r = \"qe-6.5-q2r\"\nstr_matdyn = \"qe-6.5-matdyn\"\ndef parse_arugments():\n    parser = argparse.ArgumentParser(\n        description=\"A script to run the AiiDA workflows to automatically compute the Phono Dispersion.\"\n    )\n    group = parser.add_mutually_exclusive_group(required=True)\n    parser.add_argument(",
        "detail": "examples.ph.run_ph_bands",
        "documentation": {}
    },
    {
        "label": "str_ph",
        "kind": 5,
        "importPath": "examples.ph.run_ph_bands",
        "description": "examples.ph.run_ph_bands",
        "peekOfCode": "str_ph = \"qe-6.5-ph\"\nstr_q2r = \"qe-6.5-q2r\"\nstr_matdyn = \"qe-6.5-matdyn\"\ndef parse_arugments():\n    parser = argparse.ArgumentParser(\n        description=\"A script to run the AiiDA workflows to automatically compute the Phono Dispersion.\"\n    )\n    group = parser.add_mutually_exclusive_group(required=True)\n    parser.add_argument(\n        \"-S\",",
        "detail": "examples.ph.run_ph_bands",
        "documentation": {}
    },
    {
        "label": "str_q2r",
        "kind": 5,
        "importPath": "examples.ph.run_ph_bands",
        "description": "examples.ph.run_ph_bands",
        "peekOfCode": "str_q2r = \"qe-6.5-q2r\"\nstr_matdyn = \"qe-6.5-matdyn\"\ndef parse_arugments():\n    parser = argparse.ArgumentParser(\n        description=\"A script to run the AiiDA workflows to automatically compute the Phono Dispersion.\"\n    )\n    group = parser.add_mutually_exclusive_group(required=True)\n    parser.add_argument(\n        \"-S\",\n        \"--structure\",",
        "detail": "examples.ph.run_ph_bands",
        "documentation": {}
    },
    {
        "label": "str_matdyn",
        "kind": 5,
        "importPath": "examples.ph.run_ph_bands",
        "description": "examples.ph.run_ph_bands",
        "peekOfCode": "str_matdyn = \"qe-6.5-matdyn\"\ndef parse_arugments():\n    parser = argparse.ArgumentParser(\n        description=\"A script to run the AiiDA workflows to automatically compute the Phono Dispersion.\"\n    )\n    group = parser.add_mutually_exclusive_group(required=True)\n    parser.add_argument(\n        \"-S\",\n        \"--structure\",\n        metavar=\"FILENAME\",",
        "detail": "examples.ph.run_ph_bands",
        "documentation": {}
    },
    {
        "label": "parse_arugments",
        "kind": 2,
        "importPath": "examples.ph.run_ph_base",
        "description": "examples.ph.run_ph_base",
        "peekOfCode": "def parse_arugments():\n    parser = argparse.ArgumentParser(\n        description=\"A script to run the AiiDA workflows to automatically compute the MLWF using the SCDM method and the automated protocol described in the Vitale et al. paper\"\n    )\n    parser.add_argument(\n        \"-S\",\n        \"--structure\",\n        metavar=\"FILENAME\",\n        help=\"path to an input Structure(xsf,cif,poscar) file\",\n        required=True,",
        "detail": "examples.ph.run_ph_base",
        "documentation": {}
    },
    {
        "label": "submit_workchain",
        "kind": 2,
        "importPath": "examples.ph.run_ph_base",
        "description": "examples.ph.run_ph_base",
        "peekOfCode": "def submit_workchain(\n    structure_file,\n    node,\n    node_mode,\n    qpoints,\n    tr2_ph,\n    epsil,\n    distance,\n    system_2d,\n    start_test,",
        "detail": "examples.ph.run_ph_base",
        "documentation": {}
    },
    {
        "label": "str_ph",
        "kind": 5,
        "importPath": "examples.ph.run_ph_base",
        "description": "examples.ph.run_ph_base",
        "peekOfCode": "str_ph = \"qe-6.5-ph\"\ndef parse_arugments():\n    parser = argparse.ArgumentParser(\n        description=\"A script to run the AiiDA workflows to automatically compute the MLWF using the SCDM method and the automated protocol described in the Vitale et al. paper\"\n    )\n    parser.add_argument(\n        \"-S\",\n        \"--structure\",\n        metavar=\"FILENAME\",\n        help=\"path to an input Structure(xsf,cif,poscar) file\",",
        "detail": "examples.ph.run_ph_base",
        "documentation": {}
    },
    {
        "label": "parse_argugments",
        "kind": 2,
        "importPath": "examples.pw.run_dft_bands",
        "description": "examples.pw.run_dft_bands",
        "peekOfCode": "def parse_argugments():\n    parser = argparse.ArgumentParser(\n        \"A script to run the DFT band structure (without structural relax) using Quantum ESPRESSO starting from an automated workflow (to reuse structure), or from XSF file.\"\n    )\n    group = parser.add_mutually_exclusive_group(required=True)\n    group.add_argument(\"-x\", \"--xsf\", help=\"path to an input XSF file\")\n    group.add_argument(\n        \"-w\",\n        \"--workchain\",\n        help=\"The PK of the Wannier90BandsWorkChain - if you didn't run it, run it first using the ./run_automated_wannier.py script\",",
        "detail": "examples.pw.run_dft_bands",
        "documentation": {}
    },
    {
        "label": "submit_workchain",
        "kind": 2,
        "importPath": "examples.pw.run_dft_bands",
        "description": "examples.pw.run_dft_bands",
        "peekOfCode": "def submit_workchain(\n    structure,\n    daemon,\n    protocol,\n    parameters,\n    pseudo_family,\n    pseudos,\n    run_relax,\n    num_machines,\n    num_mpiprocs_per_machine,",
        "detail": "examples.pw.run_dft_bands",
        "documentation": {}
    },
    {
        "label": "code_str",
        "kind": 5,
        "importPath": "examples.pw.run_dft_bands",
        "description": "examples.pw.run_dft_bands",
        "peekOfCode": "code_str = \"qe-6.5-pw\"\ncode = None\ndef parse_argugments():\n    parser = argparse.ArgumentParser(\n        \"A script to run the DFT band structure (without structural relax) using Quantum ESPRESSO starting from an automated workflow (to reuse structure), or from XSF file.\"\n    )\n    group = parser.add_mutually_exclusive_group(required=True)\n    group.add_argument(\"-x\", \"--xsf\", help=\"path to an input XSF file\")\n    group.add_argument(\n        \"-w\",",
        "detail": "examples.pw.run_dft_bands",
        "documentation": {}
    },
    {
        "label": "code",
        "kind": 5,
        "importPath": "examples.pw.run_dft_bands",
        "description": "examples.pw.run_dft_bands",
        "peekOfCode": "code = None\ndef parse_argugments():\n    parser = argparse.ArgumentParser(\n        \"A script to run the DFT band structure (without structural relax) using Quantum ESPRESSO starting from an automated workflow (to reuse structure), or from XSF file.\"\n    )\n    group = parser.add_mutually_exclusive_group(required=True)\n    group.add_argument(\"-x\", \"--xsf\", help=\"path to an input XSF file\")\n    group.add_argument(\n        \"-w\",\n        \"--workchain\",",
        "detail": "examples.pw.run_dft_bands",
        "documentation": {}
    },
    {
        "label": "parse_argugments",
        "kind": 2,
        "importPath": "examples.pw.run_relax",
        "description": "examples.pw.run_relax",
        "peekOfCode": "def parse_argugments():\n    parser = argparse.ArgumentParser(\n        \"A script to run the structural relax using Quantum ESPRESSO starting from the Workchain or a structure file.\"\n    )\n    group = parser.add_mutually_exclusive_group(required=True)\n    group.add_argument(\"-x\", \"--xsf\", help=\"path to an input XSF file\")\n    group.add_argument(\n        \"-w\",\n        \"--workchain\",\n        help=\"The PK of the PwRelaxWorkChain\",",
        "detail": "examples.pw.run_relax",
        "documentation": {}
    },
    {
        "label": "submit_workchain",
        "kind": 2,
        "importPath": "examples.pw.run_relax",
        "description": "examples.pw.run_relax",
        "peekOfCode": "def submit_workchain(\n    structure,\n    daemon,\n    protocol,\n    parameters,\n    pseudo_family,\n    pseudos,\n    num_machines,\n    num_mpiprocs_per_machine,\n    system_2d,",
        "detail": "examples.pw.run_relax",
        "documentation": {}
    },
    {
        "label": "code_str",
        "kind": 5,
        "importPath": "examples.pw.run_relax",
        "description": "examples.pw.run_relax",
        "peekOfCode": "code_str = \"qe-6.5-pw\"\ndef parse_argugments():\n    parser = argparse.ArgumentParser(\n        \"A script to run the structural relax using Quantum ESPRESSO starting from the Workchain or a structure file.\"\n    )\n    group = parser.add_mutually_exclusive_group(required=True)\n    group.add_argument(\"-x\", \"--xsf\", help=\"path to an input XSF file\")\n    group.add_argument(\n        \"-w\",\n        \"--workchain\",",
        "detail": "examples.pw.run_relax",
        "documentation": {}
    },
    {
        "label": "parse_arugments",
        "kind": 2,
        "importPath": "examples.q2r.run_q2r_base",
        "description": "examples.q2r.run_q2r_base",
        "peekOfCode": "def parse_arugments():\n    parser = argparse.ArgumentParser(\n        description=\"A script to run the AiiDA q2r calculation.\"\n    )\n    parser.add_argument(\n        \"--ph\",\n        type=int,\n        help=\"pk of ph calculation\",\n    )\n    parser.add_argument(",
        "detail": "examples.q2r.run_q2r_base",
        "documentation": {}
    },
    {
        "label": "submit_workchain",
        "kind": 2,
        "importPath": "examples.q2r.run_q2r_base",
        "description": "examples.q2r.run_q2r_base",
        "peekOfCode": "def submit_workchain(\n    ph,\n    num_machines,\n    num_mpiprocs_per_machine,\n    walltime,\n    q2r_code,\n    zasr,\n    daemon,\n    group_name,\n):",
        "detail": "examples.q2r.run_q2r_base",
        "documentation": {}
    },
    {
        "label": "str_q2r",
        "kind": 5,
        "importPath": "examples.q2r.run_q2r_base",
        "description": "examples.q2r.run_q2r_base",
        "peekOfCode": "str_q2r = \"qe-6.5-q2r\"\ndef parse_arugments():\n    parser = argparse.ArgumentParser(\n        description=\"A script to run the AiiDA q2r calculation.\"\n    )\n    parser.add_argument(\n        \"--ph\",\n        type=int,\n        help=\"pk of ph calculation\",\n    )",
        "detail": "examples.q2r.run_q2r_base",
        "documentation": {}
    },
    {
        "label": "get_fermi_energy",
        "kind": 2,
        "importPath": "examples.wannier.export_bands",
        "description": "examples.wannier.export_bands",
        "peekOfCode": "def get_fermi_energy(scf_output_parameters):\n    \"\"\"get Fermi energy from scf output parameters, unit is eV\"\"\"\n    try:\n        scf_out_dict = scf_output_parameters.get_dict()\n        efermi = scf_out_dict[\"fermi_energy\"]\n        efermi_units = scf_out_dict[\"fermi_energy_units\"]\n        if efermi_units != \"eV\":\n            raise TypeError(\n                \"Error: Fermi energy is not in eV!\"\n                \"it is {}\".format(efermi_units)",
        "detail": "examples.wannier.export_bands",
        "documentation": {}
    },
    {
        "label": "plot_bands",
        "kind": 2,
        "importPath": "examples.wannier.export_bands",
        "description": "examples.wannier.export_bands",
        "peekOfCode": "def plot_bands(\n    meta, path=\"\", name=\"pw_bands\", wannier_outputs=None, save_name=\"bands\"\n):\n    from matplotlib.pyplot import plot, show, figure, savefig, xticks\n    try:\n        fermi_energy = get_fermi_energy(meta.scf_parameters)\n    except TypeError as err:\n        print(err)\n        return False\n    seekpath_parameters = meta.seekpath_parameters.get_dict()",
        "detail": "examples.wannier.export_bands",
        "documentation": {}
    },
    {
        "label": "parse_label",
        "kind": 2,
        "importPath": "examples.wannier.export_bands",
        "description": "examples.wannier.export_bands",
        "peekOfCode": "def parse_label(label):\n    if label == \"GAMMA\":\n        label = r\"$\\Gamma$\"\n    else:\n        label = r\"$%s$\" % (label)\n    return label\ndef plot_bands_json(wannier, pw_bands):\n    import json\n    from matplotlib.pyplot import figure, savefig\n    try:",
        "detail": "examples.wannier.export_bands",
        "documentation": {}
    },
    {
        "label": "plot_bands_json",
        "kind": 2,
        "importPath": "examples.wannier.export_bands",
        "description": "examples.wannier.export_bands",
        "peekOfCode": "def plot_bands_json(wannier, pw_bands):\n    import json\n    from matplotlib.pyplot import figure, savefig\n    try:\n        fermi_energy = get_fermi_energy(pw_bands.outputs.scf_parameters)\n        name = pw_bands.inputs.structure.get_formula()\n    except TypeError as err:\n        print(err)\n        return False\n    fig = figure()",
        "detail": "examples.wannier.export_bands",
        "documentation": {}
    },
    {
        "label": "export_bands",
        "kind": 2,
        "importPath": "examples.wannier.export_bands",
        "description": "examples.wannier.export_bands",
        "peekOfCode": "def export_bands(wannier, pw_bands, plot_bands):\n    wannier = load_node(wannier)\n    pw_bands = load_node(pw_bands)\n    wannier.outputs.wannier90_interpolated_bands.export(\n        \"wannier_bands.agr\", overwrite=True\n    )\n    wannier.outputs.wannier90_interpolated_bands.export(\n        \"wannier_bands.gnu\", \"gnuplot\", overwrite=True\n    )\n    wannier.outputs.wannier90_interpolated_bands.export(",
        "detail": "examples.wannier.export_bands",
        "documentation": {}
    },
    {
        "label": "parse_arugments",
        "kind": 2,
        "importPath": "examples.wannier.export_bands",
        "description": "examples.wannier.export_bands",
        "peekOfCode": "def parse_arugments():\n    parser = argparse.ArgumentParser(\n        description=\"A script to plot bands of wannier workflow and pw_bands workflow.\"\n    )\n    parser.add_argument(\n        \"-W\",\n        \"--wannier\",\n        help=\"aiida pk of Wannier Workflow\",\n    )\n    parser.add_argument(",
        "detail": "examples.wannier.export_bands",
        "documentation": {}
    },
    {
        "label": "check_codes",
        "kind": 2,
        "importPath": "examples.wannier.run_automated_wannier",
        "description": "examples.wannier.run_automated_wannier",
        "peekOfCode": "def check_codes():\n    # will raise NotExistent error\n    try:\n        codes = dict(\n            pw=orm.Code.get_from_string(str_pw),\n            pw2wannier90=orm.Code.get_from_string(str_pw2wan),\n            projwfc=orm.Code.get_from_string(str_projwfc),\n            wannier90=orm.Code.get_from_string(str_wan),\n        )\n    except NotExistent as e:",
        "detail": "examples.wannier.run_automated_wannier",
        "documentation": {}
    },
    {
        "label": "parse_arugments",
        "kind": 2,
        "importPath": "examples.wannier.run_automated_wannier",
        "description": "examples.wannier.run_automated_wannier",
        "peekOfCode": "def parse_arugments():\n    parser = argparse.ArgumentParser(\n        description=\"A script to run the AiiDA workflows to automatically compute the MLWF using the SCDM method and the automated protocol described in the Vitale et al. paper\"\n    )\n    group = parser.add_mutually_exclusive_group(required=True)\n    parser.add_argument(\n        \"-S\",\n        \"--structure\",\n        metavar=\"FILENAME\",\n        help=\"path to an input Structure(xsf,cif,poscar) file\",",
        "detail": "examples.wannier.run_automated_wannier",
        "documentation": {}
    },
    {
        "label": "update_group_name",
        "kind": 2,
        "importPath": "examples.wannier.run_automated_wannier",
        "description": "examples.wannier.run_automated_wannier",
        "peekOfCode": "def update_group_name(\n    group_name, only_valence, do_disen, do_mlwf, exclude_bands=None\n):\n    if only_valence:\n        group_name += \"_onlyvalence\"\n    else:\n        group_name += \"_withconduction\"\n    if do_disen:\n        group_name += \"_disentangle\"\n    if do_mlwf:",
        "detail": "examples.wannier.run_automated_wannier",
        "documentation": {}
    },
    {
        "label": "submit_workchain",
        "kind": 2,
        "importPath": "examples.wannier.run_automated_wannier",
        "description": "examples.wannier.run_automated_wannier",
        "peekOfCode": "def submit_workchain(\n    structure_file,\n    num_machines,\n    num_mpiprocs_per_machine,\n    protocol,\n    parameters_set,\n    parameters,\n    pseudo_family,\n    pseudos,\n    only_valence,",
        "detail": "examples.wannier.run_automated_wannier",
        "documentation": {}
    },
    {
        "label": "str_pw",
        "kind": 5,
        "importPath": "examples.wannier.run_automated_wannier",
        "description": "examples.wannier.run_automated_wannier",
        "peekOfCode": "str_pw = \"qe-6.5-pw\"\nstr_pw2wan = \"pw2wannier90\"\nstr_projwfc = \"projwfc\"\nstr_wan = \"wannier-3.1\"\nstr_opengrid = \"qe-git-opengrid@localhost\"\ngroup_name = \"scdm_workflow\"\ndef check_codes():\n    # will raise NotExistent error\n    try:\n        codes = dict(",
        "detail": "examples.wannier.run_automated_wannier",
        "documentation": {}
    },
    {
        "label": "str_pw2wan",
        "kind": 5,
        "importPath": "examples.wannier.run_automated_wannier",
        "description": "examples.wannier.run_automated_wannier",
        "peekOfCode": "str_pw2wan = \"pw2wannier90\"\nstr_projwfc = \"projwfc\"\nstr_wan = \"wannier-3.1\"\nstr_opengrid = \"qe-git-opengrid@localhost\"\ngroup_name = \"scdm_workflow\"\ndef check_codes():\n    # will raise NotExistent error\n    try:\n        codes = dict(\n            pw=orm.Code.get_from_string(str_pw),",
        "detail": "examples.wannier.run_automated_wannier",
        "documentation": {}
    },
    {
        "label": "str_projwfc",
        "kind": 5,
        "importPath": "examples.wannier.run_automated_wannier",
        "description": "examples.wannier.run_automated_wannier",
        "peekOfCode": "str_projwfc = \"projwfc\"\nstr_wan = \"wannier-3.1\"\nstr_opengrid = \"qe-git-opengrid@localhost\"\ngroup_name = \"scdm_workflow\"\ndef check_codes():\n    # will raise NotExistent error\n    try:\n        codes = dict(\n            pw=orm.Code.get_from_string(str_pw),\n            pw2wannier90=orm.Code.get_from_string(str_pw2wan),",
        "detail": "examples.wannier.run_automated_wannier",
        "documentation": {}
    },
    {
        "label": "str_wan",
        "kind": 5,
        "importPath": "examples.wannier.run_automated_wannier",
        "description": "examples.wannier.run_automated_wannier",
        "peekOfCode": "str_wan = \"wannier-3.1\"\nstr_opengrid = \"qe-git-opengrid@localhost\"\ngroup_name = \"scdm_workflow\"\ndef check_codes():\n    # will raise NotExistent error\n    try:\n        codes = dict(\n            pw=orm.Code.get_from_string(str_pw),\n            pw2wannier90=orm.Code.get_from_string(str_pw2wan),\n            projwfc=orm.Code.get_from_string(str_projwfc),",
        "detail": "examples.wannier.run_automated_wannier",
        "documentation": {}
    },
    {
        "label": "str_opengrid",
        "kind": 5,
        "importPath": "examples.wannier.run_automated_wannier",
        "description": "examples.wannier.run_automated_wannier",
        "peekOfCode": "str_opengrid = \"qe-git-opengrid@localhost\"\ngroup_name = \"scdm_workflow\"\ndef check_codes():\n    # will raise NotExistent error\n    try:\n        codes = dict(\n            pw=orm.Code.get_from_string(str_pw),\n            pw2wannier90=orm.Code.get_from_string(str_pw2wan),\n            projwfc=orm.Code.get_from_string(str_projwfc),\n            wannier90=orm.Code.get_from_string(str_wan),",
        "detail": "examples.wannier.run_automated_wannier",
        "documentation": {}
    },
    {
        "label": "group_name",
        "kind": 5,
        "importPath": "examples.wannier.run_automated_wannier",
        "description": "examples.wannier.run_automated_wannier",
        "peekOfCode": "group_name = \"scdm_workflow\"\ndef check_codes():\n    # will raise NotExistent error\n    try:\n        codes = dict(\n            pw=orm.Code.get_from_string(str_pw),\n            pw2wannier90=orm.Code.get_from_string(str_pw2wan),\n            projwfc=orm.Code.get_from_string(str_projwfc),\n            wannier90=orm.Code.get_from_string(str_wan),\n        )",
        "detail": "examples.wannier.run_automated_wannier",
        "documentation": {}
    },
    {
        "label": "dat_filename",
        "kind": 5,
        "importPath": "examples.plot-ph-dis",
        "description": "examples.plot-ph-dis",
        "peekOfCode": "dat_filename = sys.argv[1]\nlabels = [\"GAMMA\", \"X\", \"K\", \"GAMMA\", \"L\"]\nlabel_frac = 200\nlabel_numbers = []\nx_data = []\ny_data = []\nfig = figure()\nax = fig.add_subplot(1, 1, 1)\nax.grid(True, alpha=0.5)\nax.set_title(\"Phonon Dispersion\")",
        "detail": "examples.plot-ph-dis",
        "documentation": {}
    },
    {
        "label": "labels",
        "kind": 5,
        "importPath": "examples.plot-ph-dis",
        "description": "examples.plot-ph-dis",
        "peekOfCode": "labels = [\"GAMMA\", \"X\", \"K\", \"GAMMA\", \"L\"]\nlabel_frac = 200\nlabel_numbers = []\nx_data = []\ny_data = []\nfig = figure()\nax = fig.add_subplot(1, 1, 1)\nax.grid(True, alpha=0.5)\nax.set_title(\"Phonon Dispersion\")\nax.set_ylabel(r\"Frequencies ($Hz$)\")",
        "detail": "examples.plot-ph-dis",
        "documentation": {}
    },
    {
        "label": "label_frac",
        "kind": 5,
        "importPath": "examples.plot-ph-dis",
        "description": "examples.plot-ph-dis",
        "peekOfCode": "label_frac = 200\nlabel_numbers = []\nx_data = []\ny_data = []\nfig = figure()\nax = fig.add_subplot(1, 1, 1)\nax.grid(True, alpha=0.5)\nax.set_title(\"Phonon Dispersion\")\nax.set_ylabel(r\"Frequencies ($Hz$)\")\nwith open(dat_filename, \"r\") as f:",
        "detail": "examples.plot-ph-dis",
        "documentation": {}
    },
    {
        "label": "label_numbers",
        "kind": 5,
        "importPath": "examples.plot-ph-dis",
        "description": "examples.plot-ph-dis",
        "peekOfCode": "label_numbers = []\nx_data = []\ny_data = []\nfig = figure()\nax = fig.add_subplot(1, 1, 1)\nax.grid(True, alpha=0.5)\nax.set_title(\"Phonon Dispersion\")\nax.set_ylabel(r\"Frequencies ($Hz$)\")\nwith open(dat_filename, \"r\") as f:\n    x_data = [float(row.split()[0]) for row in f.readlines()]",
        "detail": "examples.plot-ph-dis",
        "documentation": {}
    },
    {
        "label": "x_data",
        "kind": 5,
        "importPath": "examples.plot-ph-dis",
        "description": "examples.plot-ph-dis",
        "peekOfCode": "x_data = []\ny_data = []\nfig = figure()\nax = fig.add_subplot(1, 1, 1)\nax.grid(True, alpha=0.5)\nax.set_title(\"Phonon Dispersion\")\nax.set_ylabel(r\"Frequencies ($Hz$)\")\nwith open(dat_filename, \"r\") as f:\n    x_data = [float(row.split()[0]) for row in f.readlines()]\nfor i in range(len(labels)):",
        "detail": "examples.plot-ph-dis",
        "documentation": {}
    },
    {
        "label": "y_data",
        "kind": 5,
        "importPath": "examples.plot-ph-dis",
        "description": "examples.plot-ph-dis",
        "peekOfCode": "y_data = []\nfig = figure()\nax = fig.add_subplot(1, 1, 1)\nax.grid(True, alpha=0.5)\nax.set_title(\"Phonon Dispersion\")\nax.set_ylabel(r\"Frequencies ($Hz$)\")\nwith open(dat_filename, \"r\") as f:\n    x_data = [float(row.split()[0]) for row in f.readlines()]\nfor i in range(len(labels)):\n    if labels[i] == \"GAMMA\":",
        "detail": "examples.plot-ph-dis",
        "documentation": {}
    },
    {
        "label": "fig",
        "kind": 5,
        "importPath": "examples.plot-ph-dis",
        "description": "examples.plot-ph-dis",
        "peekOfCode": "fig = figure()\nax = fig.add_subplot(1, 1, 1)\nax.grid(True, alpha=0.5)\nax.set_title(\"Phonon Dispersion\")\nax.set_ylabel(r\"Frequencies ($Hz$)\")\nwith open(dat_filename, \"r\") as f:\n    x_data = [float(row.split()[0]) for row in f.readlines()]\nfor i in range(len(labels)):\n    if labels[i] == \"GAMMA\":\n        labels[i] = r\"$\\Gamma$\"",
        "detail": "examples.plot-ph-dis",
        "documentation": {}
    },
    {
        "label": "ax",
        "kind": 5,
        "importPath": "examples.plot-ph-dis",
        "description": "examples.plot-ph-dis",
        "peekOfCode": "ax = fig.add_subplot(1, 1, 1)\nax.grid(True, alpha=0.5)\nax.set_title(\"Phonon Dispersion\")\nax.set_ylabel(r\"Frequencies ($Hz$)\")\nwith open(dat_filename, \"r\") as f:\n    x_data = [float(row.split()[0]) for row in f.readlines()]\nfor i in range(len(labels)):\n    if labels[i] == \"GAMMA\":\n        labels[i] = r\"$\\Gamma$\"\n    else:",
        "detail": "examples.plot-ph-dis",
        "documentation": {}
    },
    {
        "label": "xbars",
        "kind": 5,
        "importPath": "examples.plot-ph-dis",
        "description": "examples.plot-ph-dis",
        "peekOfCode": "xbars = []\nfor ilabel in range(len(labels)):\n    if len(label_numbers) != len(label_frac):\n        pass\n    else:\n        xbar = kxcoords[label_numbers[ilabel]]\n        ax.vlines(\n            xbar,\n            ymin,\n            ymax,",
        "detail": "examples.plot-ph-dis",
        "documentation": {}
    },
    {
        "label": "plot_centres_xsf",
        "kind": 2,
        "importPath": "examples.plot_wannier_centres",
        "description": "examples.plot_wannier_centres",
        "peekOfCode": "def plot_centres_xsf(structure, w90_calc):\n    a = structure.get_ase()\n    new_a = a.copy()\n    out = w90_calc.out.output_parameters.get_dict()[\"wannier_functions_output\"]\n    coords = [i[\"coordinates\"] for i in out]\n    for c in coords:\n        new_a.append(ase.Atom(\"X\", c))\n    new_a.write(\"./wannier.xsf\")\nif __name__ == \"__main__\":\n    s_pk = int(sys.argv[1])",
        "detail": "examples.plot_wannier_centres",
        "documentation": {}
    }
]